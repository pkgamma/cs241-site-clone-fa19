<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from cs241.cs.illinois.edu/coursebook/Deadlock by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 17 Dec 2019 18:37:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">

  <!-- If for some reason you are using IE, use edge -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- So bootstrap isn't horrible, set the width -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" type="image/png" href="../images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="../images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="../images/favicons/manifest.json">
  <link rel="mask-icon" href="../images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>CS 241 Â· Deadlock</title>

  <!-- Reference a CDN so this is properly cached in the browser forever. Unless they clean out the
       Cache this will incur no load time. Ideally we should put a security checksum but that breaks
       Firefox development sometimes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">

  <!-- Asynchronously load the code style sheet because we want everything loaded as fast as possible
       Also tag with ?v=time to bust the cache of any browser so updates appear -->
  <style rel="stylesheet" type="text/css">.highlight table td{padding:5px}.highlight table pre{margin:0}.highlight,.highlight .w{color:#93a1a1;background-color:#002b36}.highlight .err{color:#002b36;background-color:#dc322f}.highlight .c,.highlight .cd,.highlight .cm,.highlight .c1,.highlight .cs{color:#657b83}.highlight .cp{color:#b58900}.highlight .nt{color:#b58900}.highlight .o,.highlight .ow{color:#93a1a1}.highlight .p,.highlight .pi{color:#93a1a1}.highlight .gi{color:#859900}.highlight .gd{color:#dc322f}.highlight .gh{color:#268bd2;background-color:#002b36;font-weight:bold}.highlight .k,.highlight .kn,.highlight .kp,.highlight .kr,.highlight .kv{color:#6c71c4}.highlight .kc{color:#cb4b16}.highlight .kt{color:#cb4b16}.highlight .kd{color:#cb4b16}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .sh,.highlight .sx,.highlight .s1{color:#859900}.highlight .sr{color:#2aa198}.highlight .si{color:#d33682}.highlight .se{color:#d33682}.highlight .nn{color:#b58900}.highlight .nc{color:#b58900}.highlight .no{color:#b58900}.highlight .na{color:#268bd2}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .il,.highlight .mo,.highlight .mb,.highlight .mx{color:#859900}.highlight .ss{color:#859900}
/*# sourceMappingURL=/assets/source-maps/code-style.css.map */
/*# sourceURL=css/code-style.css */
</style>
  <style rel="stylesheet" type="text/css">:root{--color-primary: hsl(207, 59%, 43%);--color-secondary: hsl(207, 70%, 53%);--color-emphasis: hsl(204, 100%, 42%);--color-text: hsl(0, 0%, 0%);--color-translucent: hsla(0, 0%, 0%, 0.3);--color-pale-white: hsla(240, 8%, 95%)}body{padding-top:50px;font-family:Roboto, Helvetica, Arial, sans-serif;background-color:var(--color-pale-white);color:var(--color-text);padding-bottom:50px}@media (min-width: 768px) and (max-width: 991px){body{padding-top:100px}}.navbar{background-color:var(--color-primary);border-color:var(--color-secondary);border:0px;border-top:none;box-shadow:none;margin-bottom:0}.navbar-default .navbar-brand{color:var(--color-pale-white) !important;font-weight:bold}.navbar-default .navbar-nav>li>a{color:var(--color-pale-white) !important}.navbar-collapse{border-top:0px !important;box-shadow:none}.navbar-brand:hover{color:var(--color-navbar-text) !important}.github-link{display:inline-block;vertical-align:middle;margin-left:0.5em;text-indent:-9999px;width:32px;height:32px;background-image:url(NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgNjQgNjQiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDY0IDY0IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBmaWxsPSIjMTgxNjE2IiBkPSJNMzIuNiwzLjRDMTYuMywzLjQsMywxNi43LDMsMzMuMWMwLDEzLjEsOC41LDI0LjIsMjAuMywyOC4xDQoJYzEuNSwwLjMsMi0wLjYsMi0xLjRjMC0wLjcsMC0yLjYsMC01Yy04LjIsMS44LTEwLTQtMTAtNGMtMS4zLTMuNC0zLjMtNC4zLTMuMy00LjNjLTIuNy0xLjgsMC4yLTEuOCwwLjItMS44YzMsMC4yLDQuNSwzLjEsNC41LDMuMQ0KCWMyLjYsNC41LDYuOSwzLjIsOC42LDIuNWMwLjMtMS45LDEtMy4yLDEuOS00Yy02LjYtMC43LTEzLjUtMy4zLTEzLjUtMTQuNmMwLTMuMiwxLjItNS45LDMtNy45Yy0wLjMtMC43LTEuMy0zLjgsMC4zLTcuOA0KCWMwLDAsMi41LTAuOCw4LjEsM2MyLjQtMC43LDQuOS0xLDcuNC0xYzIuNSwwLDUsMC4zLDcuNCwxYzUuNy0zLjgsOC4xLTMsOC4xLTNjMS42LDQuMSwwLjYsNy4xLDAuMyw3LjhjMS45LDIuMSwzLDQuNywzLDcuOQ0KCWMwLDExLjQtNi45LDEzLjktMTMuNSwxNC42YzEuMSwwLjksMiwyLjcsMiw1LjVjMCw0LDAsNy4yLDAsOC4xYzAsMC44LDAuNSwxLjcsMiwxLjRjMTEuOC0zLjksMjAuMi0xNSwyMC4yLTI4LjENCglDNjIuMiwxNi43LDQ5LDMuNCwzMi42LDMuNHoiLz4NCjwvc3ZnPg0K)}h1{padding-bottom:20px;font-size:48px}h2{padding-top:50px;margin-top:-20px}.navbar-nav,.navbar-nav>ul{margin:0}@media (max-width: 767px){h1{font-size:36px}h2{font-size:22px}p,li{font-size:12px}}.popover{background-color:black;color:black;display:block}.popover-title{background-color:black;color:black;font-size:12px;text-align:center;border-bottom:0px}.popover-title a{color:white;cursor:pointer}.popover-content{background-color:black;padding:0px}.popover.top>.arrow:after{border-top-color:black}table{width:100%}.anchor{display:none;padding-left:5px}.title-text:hover>.anchor{display:inline}.day{height:300px;margin-bottom:20px;width:100%;background-color:#fff;border-radius:3px}.day h1{color:#f1f1f3}.day-summary,.day-resources{color:#000}.day-resources{position:absolute;bottom:20px}.day-summary{position:absolute;top:75px}.day-title-text h3{margin:0px}.day-title{padding-top:5px;padding-bottom:5px;border-radius:3px;height:70px}.schedule-container{margin-left:20px;margin-right:20px}ul.toc{list-style:none;padding-left:1em}h1,h2,h3{color:var(--color-secondary)}.announcement-card{background-color:var(--color-pale-white);border-radius:5px}.annoucement-title{margin-top:5px}.day-title-h3{color:var(--color-pale-white)}img:not(.emoji){max-height:80vh;display:inline-block;margin:auto;max-width:100%}.img-paragraph{display:grid}.hidden{display:none !important}.loader,.loader:before,.loader:after{border-radius:50%}.loader{color:var(--color-pale-white);font-size:11px;text-indent:-99999em;margin:55px auto;position:relative;width:10em;height:10em;box-shadow:inset 0 0 0 1em;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0)}.loader:before,.loader:after{position:absolute;content:''}.loader:before{width:5.2em;height:10.2em;background:#0dc5c1;border-radius:10.2em 0 0 10.2em;top:-0.1em;left:-0.1em;-webkit-transform-origin:5.2em 5.1em;transform-origin:5.2em 5.1em;-webkit-animation:load2 2s infinite ease 1.5s;animation:load2 2s infinite ease 1.5s}.loader:after{width:5.2em;height:10.2em;background:#0dc5c1;border-radius:0 10.2em 10.2em 0;top:-0.1em;left:5.1em;-webkit-transform-origin:0px 5.1em;transform-origin:0px 5.1em;-webkit-animation:load2 2s infinite ease;animation:load2 2s infinite ease}@-webkit-keyframes load2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes load2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.anchor{text-decoration:none}.anchor:hover{text-decoration:none}.fancy-link{text-decoration:none !important;color:var(--color-emphasis);display:inline-block;position:relative;padding-bottom:0px}.fancy-link:after{content:'';display:block;margin:auto;height:1px;width:0px;background:transparent;transition:width .3s ease, background-color .3s ease}.fancy-link:hover:after{width:100%;background:var(--color-emphasis)}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.navbar-toggle{border-width:0px}.navbar-default .navbar-toggle .icon-bar{background-color:var(--color-pale-white)}.navbar-brand.small{display:none}@media (max-width: 767px){.navbar-brand.normal{display:none}.navbar-brand.small{display:inline-block}}.speaker-wrapper{float:right}.speaker{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAQAAABpN6lAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAEZ0FNQQAAsY58+1GTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAfRSURBVHja7Z1viBzlHce/v2f+7OztbdL2FAumvsgl6okYCCrWPxDoq9BUKG05CuKLNtK+KCnaQtM/oIhR0BLsq5pUUlIq9oVgtW0gbWkj1IIttSBiKKJtQ9Ge5Pb2bndvZ3Zmnp8vZnZ2Zm42OZKZu5ndZ4a7g/u7v8/z/X2f3/N7nr0lxnRfAgqAAqAAKAAKgAKgACgACoACoAAoAAqAAqAAKAAKgAKgACgACoACoAAoAArAlVwObgNBg4CWuvXwNmDAgAkDhMdwU/he4F58H4Q7cBSEGo7h5ujr9+B7IAiIO8WjtO9HOQPQKzNUd+EYbrOuve8I5JSlgAYLWKRTtJe7M/sPzEyZAgQu4twjdIQk+tAhbKM2XQC0xnuPn1/UbfihYA0QAJ4KABbE9d4z2gGzywwABCJY0OFPBQAD525dflYsiA6FViUhCCa0PG1QL2vmE+jg2WP6NUaXwCEAAhH0fI27lAAINrzD3tGaLvoUTVUEDRpAUzAL1I3nfrj2NdMVjgjGHQDAgS4muxAiCGDOfqp3SO8JSRjeCD2Acv+LJQMgYe/BcdxudIlFOOJxBYhJB/De3e/+uHaD1iEQNFBC9BMOICh41x/lhtELxj6pAAYX4AClAaDhIl57RDsiJNnD4EcAEAKYWAUQtMb7j7+zWLfJF1HwGggUhcyQk6oAC+J69xn9QL0rGBDQwvBFzAE4LI4weQAMnLv14rNiQeuIsJUSvymllAlTQFjwPmnMGd2R7EXYUaIIAMfeTxAAgg3/sHu0pov+SPLJ8AkEBkEWNP7bCqD2yZPf6T1oupqDKOBh+CI2/gGCok61bxeAa+jz8oHVBb2vSYrGnlLhj0a8uEP9ekG/dR47slft3KRd2I+76Aby9N6o4BnN/oTkGkBGHsAVAXAPjtIeEJgSGc9BQDpZEMLBusYUK3lEKvzRupdQ5JM6cgfAd+MUzcAZhR//SCCgT0xhkUMbwtfCNWHa8IqaCXIGYGtLh9GkDiVCj4MYNjjisqfMkR8GzKH8uZAkyFsBDXkj+hQFG8h3uJyhSAUBBhHpgGJ1/+i7UWDuFwWgJoygfh/O4CIa9ySAUeAiUkS89qeEBrgSJkggmIgmsHQwIkRCCQRJ1x+lwMj54ylQdgA6TEHxOVyksh+ZGqBU3o98n1PZzyUHoMEQseAQG9F4+Ehkfbrzlzm3FFYQ5esBBI0oWcyMgzAueI6lTbIAkvluCxdVByTlnQSQhJE96hyr/TlshBRZDOvFhJ9la2kdpCe9YNWXXgBzzAorUAghNf6XAhCfHuOhyQ1lkARDVmctME4BWRjG2132Z7gKADZmOWUWxMm8zwovWQFUZzUYZXbW+G8Mcfx5h2QVWI21QMzZKeX7V7XGrFhDZFMB0WWD40QxXGEAnKkB3hSmolcDYmtG+2p+klN+UPaOUPhQCTJGl6/qt8lUfVD6FBiFL0EQV/zQCTJMH1mYPkUxkudc+nicURZXRAEjp+ccYBbXDlHH5RWAQmaBPMQ/rhguvwKoqKqtGtvjku1gSygYNZGTArgiHqDNdPa9bVsbC9g87mJQ5KwAnZ789TsL/9ldc4Otz42rQWLBgomvxFeqUAdo+z7840+ePviXva6ZdbKXeGCtWqt1EnVXk5cPKR52FUphCQ80v3Li5fUdUstuAzC9O/vGZ/6099zN7WbD1eR2GyFxnn5iook5zKEJc8yptqD940N787qTd77wWb9muZtRQJAEA32udf7Bnf+FEzyBpmwKYPhw0IUBhgV9DIDgHIzc/+FzLx86/+0vXfj0rEPYvqsIAIwBrDHP7AjOQekwYEI/dH73yW985fVbmg4xbUIB1fCAPnw4MKCNAUDQYcCCBQv1W5Ze+fl3D52+ty51P6s9Gt8jrkZX2AfDxyA86DsuBXSYqGMGs2h8Cqde2rN07Au2WXM31x4p+3I42MZxL9EKDpKgjz4cuGjC+sGfFy5+68tL1844xRyG3Op+wOUGyocHF4PwzUMTjS++tXv564v/uHHWEZydApO1HGb4cLGOLtpoYQVrkPs++N3zi3/tGq5W7JmgLekIbRrCABI+PHjw0byu8+Kv9nz09EHfMF3O2CWubFv8ksngoo81rKCFNmxyn/j96dM7Vnu1ccuhyesISbiw0cEKltFGD/Krb545sfDvniVpuCXOhS6It78lxvBgo4tVLGMFHfAdF87+7P6/r5u+2IppsAw9wcANelhFCytYhber/dIvHz7jYLAFDlWWpqiPAdaxhhZaaMMx3ONnTrzQ6K2bPDVtcRkZYugGD/3tNyfn/9e3eCoUMHQDBx20QzeQ971/9sTn/mnXpJhsD0giGLpBC2vw5luv/uKbfxiI4sqj8m2MjAxxGW0MZuyfvnr8RdMemEE/afIBDN2ggzZaaKMP/+HXX3l+1/8HdTY8l3JuDWqPoZQXQ8KHH/67FGO+dfBfF2pLjQd+e/8bYgA3v3ygEr/IigYTFmaxA5/ALAzQKu38AB9hBevl7AkW4QYyVIKHWeg7HfjRk8imAADgQ4YIPLioQcKBmy+Csv8nKQ67jB4GsMBwMMhP/mX3gOgxQsBADToIXt4IqBKvNDXcTQgWTrmmAFXmpbYo6prztKXA1CyGFAAFQAFQABQABUABUAAUAAVAAVAAFAAFQAFQABQABWALro8B0vUmf5f9kKEAAAAASUVORK5CYII=");background-size:cover;height:40px;width:40px;margin-top:5px}pre{color:var(--color-pale-white);background-color:var(--color-text);border:inherit}code{color:var(--color-pale-white)}.code-copy{float:right;right:0px;display:none;background-color:var(--color-text);padding:5px 5px 5px 5px;border-radius:3px;cursor:pointer}pre code{display:block}pre:hover>*>.code-copy{display:inline}.code-copy-textarea{position:absolute;left:-9999px;top:-9999px}pre.highlight{margin-bottom:-10px;padding-bottom:0px}.highlighter-rouge{background-color:#DFDFDF;color:#151515;border-radius:5px;padding-top:4px}.highlight{background-color:#151515;border:0px;color:#F2F2F4}div.highlighter-rouge,figure.highlighter-rouge{background-color:#151515;color:#D7D7D7;padding-bottom:1.5em;margin-bottom:0.65em}.fancy-link code{color:#337ab7}.fancy-link:hover code{color:#23527c}.fancy-link:hover:after code{background-color:#337ab7}.table>tbody>tr>td,table>tbody>tr>td,.table>tbody>tr>th,table>tbody>tr>th,.table>tfoot>tr>td,table>tfoot>tr>td,.table>tfoot>tr>th,table>tfoot>tr>th,.table>thead>tr>td,table>thead>tr>td,.table>thead>tr>th,table>thead>tr>th{border-top:0px}.table,table{margin-left:40px;width:75%}.search-icon-div{width:initial;padding-left:10px;background-color:white;height:34px;border-radius:3px 0px 0px 3px}.glyphicon-search{font-size:32px;top:0px;color:#2C72AD}.search{border-radius:0px 3px 3px 0px;border:0px;outline:none;box-shadow:none}.no-gutter>[class*='col-']{padding-right:0;padding-left:0}.result-link{font-size:24px;text-decoration:underline}.result-div{padding-bottom:12px}.highlight-result{background-color:yellow;border-radius:3px;color:black;padding-left:2px;padding-right:2px}tbody tr:nth-child(odd){background-color:#DDD;border-radius:20px}html.hacker,body.hacker,header.hacker,nav.hacker,:not(.card-staff)>*>div:not(.card-staff).hacker,table.hacker,pre.hacker,span.hacker,:not(.card-staff)>a.hacker,p.hacker,h1.hacker,h2.hacker,h3.hacker,h4.hacker,h5.hacker,h6.hacker{color:white !important;font-family:monospace !important;background-color:black !important}h1.hacker,h2.hacker,h3.hacker,h4.hacker,h5.hacker,h6.hacker{color:#20C20E !important}ul.hacker{list-style-type:square}pre.hacker{border-color:white;border-radius:0}.toc.hacker{border-left-width:0}.content .highlighter-rouge.hacker{font-weight:bold;background-color:black}.pad.hacker{padding:0}a.hacker{color:#20C20E}tbody tr:nth-child(odd).hacker{background-color:inherit}body.hacker .day,body.hacker .announcement-card{background-color:#151515}body.hacker .announcement{color:white !important}#tuxlink img.hacker{-ms-interpolation-mode:nearest-neighbor;image-rendering:pixelated}.apply-button{border:none;background-color:white;padding:10px 20px 10px 20px;font-size:36px;border-radius:5px;box-shadow:5px 5px gray;margin:10px auto 10px auto;display:block;transition:background-color 0.5s ease}.apply-button:hover{background-color:var(--color-primary)}li.navbar-subitem{float:left;overflow:hidden;width:100%}.navbar-item,.navbar-subitem{color:var(--color-navbar-text);text-align:center;font-family:'Roboto', sans-serif}li.navbar-item:hover,li.navbar-subitem:hover{background-color:white}li.navbar-item:hover>a,li.navbar-subitem:hover>a{color:var(--color-primary) !important}.subitem-container{display:none;position:absolute;min-width:8vw;background-color:var(--color-primary);box-shadow:0px 8px 16px 0px var(--color-translucent);z-index:1;width:100%}.navbar-item:hover .subitem-container{display:block}.staff{width:100%}.flexbox-item div.staff-image{width:18vh;height:18vh;overflow:hidden;background-size:cover;padding:0;border-radius:50%}.flexbox-item:hover div.staff-image{box-shadow:0 4px 12px 0 var(--color-translucent),0 6px 20px 0 var(--color-translucent)}.staff-name{bottom:0px;width:100%;text-align:center;font-weight:100;padding-top:2vh;color:var(--color-secondary-emphasis)}.heading{text-align:center;font-family:Roboto, Helvetica, sans-serif;font-size:3em;padding:1em;padding:0}section.center{text-align:center;padding-left:3vw;padding-right:3vw;padding-bottom:0;padding-top:0}main{text-align:center;margin:0;padding:0;background-color:white}.card-body{background-color:var(--color-pale-white);padding:2vh;display:block}.card-body.course-heading{background-color:rgba(72,105,255,0.945)}.card-body.card-body.course-heading h1{color:white}.card-body.course-information{background-color:white}h2{font-weight:200}section.flexbox{display:flex;justify-content:center;margin:auto;flex-wrap:wrap;width:90vw}.flexbox-item{display:inline-block;padding:2vh;margin:2vh}img.logo{width:2vw;height:3vw;margin:2vh}@media (max-width: 480px){.flexbox-item div.staff-image{width:18vh;height:18vh}img.logo{width:10vw;height:8vh}.staff-name{font-size:0.75em}}.infrastructure-links{margin:auto;text-align:center;display:block}.gallery{display:flex;justify-content:center;margin:auto;padding:5vw;flex-wrap:wrap;width:100vw}.staff{width:100%}.staff-container{margin:2vh}.staff-container div.staff-image{width:24vh;height:24vh;overflow:hidden;background-size:cover;padding:0;border-radius:50%}.staff-container:hover div.staff-image{box-shadow:0 4px 12px 0 var(--color-translucent),0 6px 20px 0 var(--color-translucent)}.staff-name{bottom:0px;width:100%;text-align:center;font-size:1.5em;padding-top:1vh;color:var(--color-emphasis)}.heading{text-align:center}section.center{text-align:center;padding-left:3vw;padding-right:3vw;padding-bottom:0;padding-top:0}@media only screen and (max-width: 480px){.staff-container div.staff-image{width:20vh;height:20vh}.staff-name{font-size:1.25em}}.latest-mp{background-color:rgba(16,213,147,0.85)}.latest-lab{background-color:rgba(255,102,42,0.85)}.latest-assignments section.flexbox-item{border-radius:4%}
/*# sourceMappingURL=/assets/source-maps/main.css.map */
/*# sourceURL=css/main.css */
</style>

  <meta property="og:locale" content="en_US">
  
  
  <meta property="og:title" content="Deadlock" />
  
  
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://cs241.cs.illinois.edu" />
  
  
  <meta property="og:description" content=""Webpage for CS 241: System Programming at the University of Illinois at Urbana-Champaign. All documentation and information about the course can be found here."
" />
  

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <!-- Navigation button as html so we don't have to resize images -->
      <button
        type="button"
        class="navbar-toggle collapsed"
        data-toggle="collapse"
        data-target=".navbar-collapse"
        aria-expanded="false"
        aria-controls="navbar"
      >
        <!-- Hamburger Navigation bar on small -->
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <!-- Full title on laptop -->
      <a class="navbar-brand navbar-item normal" href="../index.html">
             <span>CS 241: System Programming</span> 
      </a>

      <!-- Smaller on mobile-->
      <a class="navbar-brand navbar-item small" href="../index.html">
          <span>CS 241</span>
      </a>
    </div>

    <!-- Finally generate what is in the navbar -->
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
        <li class="navbar-item">
          <a href="../assignments.html">Assignments</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../quiz_topics.html">Quizzes</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../grades.html">Grades</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../schedule.html">Schedule</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="../lectures.html">Lectures</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../syllabus.html">Syllabus</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../staff.html">Staff</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="../staff_hall_of_fame.html">Staff Hall of Fame</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../resources.html">Resources</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="../peer_tutoring.html">Peer Tutoring</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="index.html">Coursebook</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../honors.html">Honors</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
      </ul>
    </div>
  </div>
  <!-- Fonts -->
  <link
    href="https://fonts.googleapis.com/css?family=Roboto"
    rel="stylesheet"
  />
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            
            
            
            <h1>
              Deadlock

              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
            
          </div></div></div>
        </div></div>
      </div>
      
      <div id="content">
          <div class="wrapper">

</div>
          <div class="wrapper">
<ul>
  <li>
<a href="#deadlock" class="fancy-link wiki-link">Deadlock</a>
    <ul>
      <li><a href="#resource-allocation-graphs" class="fancy-link wiki-link">Resource Allocation Graphs</a></li>
      <li><a href="#coffman-conditions" class="fancy-link wiki-link">Coffman Conditions</a></li>
      <li>
<a href="#approaches-to-solving-livelock-and-deadlock" class="fancy-link wiki-link">Approaches to Solving Livelock and
Deadlock</a>
        <ul>
          <li><a href="#extra-bankers-algorithm" class="fancy-link wiki-link">Extra: Bankerâs Algorithm</a></li>
        </ul>
      </li>
      <li>
<a href="#dining-philosophers" class="fancy-link wiki-link">Dining Philosophers</a>
        <ul>
          <li><a href="#failed-solutions" class="fancy-link wiki-link">Failed Solutions</a></li>
        </ul>
      </li>
      <li>
<a href="#viable-solutions" class="fancy-link wiki-link">Viable Solutions</a>
        <ul>
          <li><a href="#leaving-the-table-stallings-solution" class="fancy-link wiki-link">Leaving the Table (Stallingsâ
Solution)</a></li>
          <li><a href="#partial-ordering-dijkstras-solution" class="fancy-link wiki-link">Partial Ordering (Dijkstraâs
Solution)</a></li>
          <li><a href="#extra-cleandirty-forks-chandymisra-solution" class="fancy-link wiki-link">Extra: Clean/Dirty Forks (Chandy/Misra
Solution)</a></li>
          <li><a href="#extra-actor-model" class="fancy-link wiki-link">Extra: Actor Model</a></li>
        </ul>
      </li>
      <li><a href="#topics" class="fancy-link wiki-link">Topics</a></li>
      <li><a href="#questions" class="fancy-link wiki-link">Questions</a></li>
    </ul>
  </li>
</ul>

<p><span> </span></p>



<p><strong>No, you canât always get what you want<br>
You canât always get what you want<br>
You canât always get what you want<br>
But if you try sometimes you find<br>
You get what you need</strong> - <strong>The philosophers Jagger &amp; Richards</strong></p>

<p>Deadlock is defined as when a system cannot make and forward progress.
We define a system for the rest of the chapter as a set of rules by
which a set of processes can move from one state to another, where a
state is either working or waiting for a particular resource. Forward
progress is defined as if there is at least one process working or we
can award a process waiting for a resource that resource. In a lot of
systems, Deadlock is avoided by ignoring the entire concept
(Silberschatz, Galvin, and Gagne
<a href="#ref-silberschatz2006operating" class="fancy-link wiki-link">#ref-silberschatz2006operating</a>,
P.237). Have you heard about turn it on and off again? For products
where the stakes are low (User Operating Systems, Phones), it may be
more efficient to allow deadlock. But in the cases where âfailure is not
an optionâ - Apollo 13, you need a system that tracks, breaks, or
prevents deadlocks. Apollo 13 didnât fail because of deadlock, but it
wouldnât be good to restart the system on liftoff.</p>

<p>Mission-critical operating systems need this guarantee formally because
playing the odds with peopleâs lives isnât a good idea. Okay so how do
we do this? We model the problem. Even though it is a common statistical
phrase that all models are wrong, the more accurate the model is to the
system the higher the chance the method will work.</p>

<div class="pad"><div class="card">
<div class="title"><h2 id="resource-allocation-graphs" class="title-text">Resource Allocation Graphs<a class="anchor title-text" href="#resource-allocation-graphs">#</a>
</h2></div>









<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/deadlock/drawings/rag.png" alt='Resource allocation
graph&lt;span label="ragfigure"&gt;&lt;/span&gt;'></p>
<p>One such way is modeling the system with a resource allocation graph
(RAG). A resource allocation graph tracks which resource is held by
which process and which process is waiting for a resource of a
particular type. It is a simple yet powerful tool to illustrate how
interacting processes can deadlock. If a process is <em>using</em> a resource,
an arrow is drawn from the resource node to the process node. If a
process is <em>requesting</em> a resource, an arrow is drawn from the process
node to the resource node. If there is a cycle in the Resource
Allocation Graph and each resource in the cycle provides only one
instance, then the processes will deadlock. For example, if process 1
holds resource A, process 2 holds resource B and process 1 is waiting
for B and process 2 is waiting for A, then processes 1 and 2 will be
deadlocked <a href="#ragfigure" class="fancy-link wiki-link">#ragfigure</a>. Weâll make the
distinction that the system is in deadlock by definition if all workers
cannot perform an operation other than waiting. We can detect a deadlock
by traversing the graph and searching for a cycle using a graph
traversal algorithm, such as the Depth First Search (DFS). This graph is
considered as a directed graph and we can treat both the processes and
resources as nodes.</p>
<pre><code class="language-C">    typedef struct {
        int node_id; // Node in this particular graph
        Graph **reachable_nodes; // List of nodes that can be reached from this node
        int size_reachable_nodes; // Size of the List
    } Graph;
    
    // isCyclic() traverses a graph using DFS and detects whether it has a cycle
    // isCyclic() uses a recursive approach
    // G points to a node in a graph, which can be either a resource or a process
    // is_visited is an array indexed with node_id and initialized with zeros (false) to record whether a particular node has been visited
    int isCyclic(Graph *G, int* is_visited) {
        if (this graph has been visited) {
            // Oh! the cycle is found
            return true;
            } else {
            1. Mark this node as visited
            2. Traverse through all nodes in the reachable_nodes
            3. Call isCyclic() for each node
            4. Evaluate the return value of isCyclic()
        }
        // Nope, this graph is acyclic
        return false;
    }
</code></pre>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/deadlock/drawings/deadlock.png" alt="Graph based
Deadlock"></p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="coffman-conditions" class="title-text">Coffman Conditions<a class="anchor title-text" href="#coffman-conditions">#</a>
</h2></div>























<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Surely cycles in RAGs happen all the time in an OS, so why doesnât it
grind to a halt? You may not see deadlock because the OS may <strong>preempt</strong>
some processes breaking the cycle but there is still a chance that your
three lonely processes could deadlock.</p>
<p>There are four <em>necessary</em> and <em>sufficient</em> conditions for deadlock â
meaning if these conditions hold then there is a non-zero probability
that the system will deadlock at any given iteration. These are known as
the Coffman Conditions (Coffman, Elphick, and Shoshani
<a href="#ref-coffman1971system" class="fancy-link wiki-link">#ref-coffman1971system</a>).</p>
<ul>
  <li>
    <p>Mutual Exclusion: No two processes can obtain a resource at the same
time.</p>
  </li>
  <li>
    <p>Circular Wait: There exists a cycle in the Resource Allocation
Graph, or there exists a set of processes {P1, P2,â¦} such that P1 is
waiting for resources held by P2, which is waiting for P3,â¦, which
is waiting for P1.</p>
  </li>
  <li>
    <p>Hold and Wait: Once a resource is obtained, a process keeps the
resource locked.</p>
  </li>
  <li>
    <p>No pre-emption: Nothing can force the process to give up a resource.</p>
  </li>
</ul>
<p><strong>(Optional) Proof:</strong><br>
Deadlock can happen if and only if the four Coffman conditions are
satisfied.</p>
<p><script type="math/tex">â</script> If the system is deadlocked, the four Coffman conditions are
apparent.</p>
<ul>
  <li>
    <p>For contradiction, assume that there is no circular wait. If not
then that means the resource allocation graph is acyclic, meaning
that there is at least one process that is not waiting on any
resource to be freed. Since the system can move forward, the system
is not deadlocked.</p>
  </li>
  <li>
    <p>For contradiction, assume that there is no mutual exclusion. If not,
that means that no process is waiting on any other process for a
resource. This breaks circular wait and the previous argument proves
correctness.</p>
  </li>
  <li>
    <p>For contradiction, assume that processes donât hold and wait but our
system still deadlocks. Since we have circular wait from the first
condition at least one process must be waiting on another process.
If that and processes donât hold and wait, that means one process
must let go of a resource. Since the system has moved forward, it
cannot be deadlocked.</p>
  </li>
  <li>
    <p>For contradiction, assume that we have preemption, but the system
cannot be un-deadlocked. Have one process, or create one process,
that recognizes the circular wait that must be apparent from above
and break one of the links. By the first branch, we must not have
deadlocked.</p>
  </li>
</ul>
<p><script type="math/tex">â</script> If the four conditions are apparent, the system is deadlocked.
We will prove that if the system is not deadlocked, the four conditions
are not apparent. Though this proof is not formal, let us build a system
with the three requirements not including circular wait. Let assume that
there is a set of processes <script type="math/tex">P = \{p_1, p_2, ..., p_n\}</script> and there
is a set of resources <script type="math/tex">R = \{r_1, r_2, ..., r_m\}</script>. For simplicity,
a process can only request one resource at a time but the proof can be
generalized to multiple. Let assume that the system is a state at time
<script type="math/tex">t</script>. Let us assume that the state of the system is a tuple
<script type="math/tex">(h_t, w_t)</script> where there are two functions
<script type="math/tex">h_t: R âP âª\{\text{unassigned}\}</script> that maps resources to the
processes that own them (this is a function, meaning that we have mutual
exclusion) and or unassigned and <script type="math/tex">w_t: P âR âª\{\text{satisfied}\}</script>
that maps the requests that each process makes to a resource or if the
process is satisfied. If the process is satisfied, we consider the work
trivial and the process exits, releasing all resources â this can also
be generalized. Let <script type="math/tex">L_t âP ÃR</script> be a set of lists of requests that a
process uses to release a resource at any given time. The evolution of
the system is at each step at every time.</p>
<ul>
  <li>
    <p>Release all resources in <script type="math/tex">L_t</script>.</p>
  </li>
  <li>
    <p>Find a process that is requesting a resource</p>
  </li>
  <li>
    <p>If that resource is available give it to that process, generating a
new <script type="math/tex">(h_{t+1}, w_{t+1})</script> and exit the current iteration.</p>
  </li>
  <li>
    <p>Else find another process and try the same resource allocation
procedure in the previous step.</p>
  </li>
</ul>
<p>If all processes have been surveyed and if all are requesting a resource
and none can be granted a resource, consider it deadlocked. More
formally, this system is deadlocked means if
<script type="math/tex">ât_0, ât â¥t_0, âp âP, w_t(p) â \text{satisfied} \text{ and } âq, q â p âh_t(w_t(p)) = q</script>
(which is what we need to prove).</p>
<p>Mutual exclusion and no pre-emption are encoded into the system.
Circular wait implies the second condition, a resource is owned by
another process which is owned by another process meaning at this state
<script type="math/tex">âp âP, âq â p âh_t(w_t(p)) = q</script>. Circular wait also implies that at
this current state, no process is satisfied, meaning at this state
<script type="math/tex">âp âP, w_t(p) â \text{satisfied}</script>. Hold and wait simply proves the
condition that from this point onward, the system will not change, which
is all the conditions that we needed to show.<br>
<strong>(Optional) â </strong><br>
If a system breaks any of them, it cannot have deadlock! Consider the
scenario where two students need to write both pen and paper and there
is only one of each. Breaking mutual exclusion means that the students
share the pen and paper. Breaking circular wait could be that the
students agree to grab the pen then the paper. As proof by
contradiction, say that deadlock occurs under the rule and the
conditions. Without loss of generality, that means a student would have
to be waiting on a pen while holding the paper and the other waiting on
a pen and holding the paper. We have contradicted ourselves because one
student grabbed the paper without grabbing the pen, so deadlock fails to
occur. Breaking hold and wait could be that the students try to get the
pen and then the paper and if a student fails to grab the paper then
they release the pen. This introduces a new problem called <em>livelock</em>
which will be discussed later. Breaking preemption means that if the two
students are in deadlock the teacher can come in and break up the
deadlock by giving one of the students a held item or tell both students
to put the items down.</p>
<p>livelock relates to deadlock. Consider the breaking hold-and-wait
solution as above. Though deadlock is avoided, if the philosopher picks
up the same device again and again in the same pattern, no work will be
done. Livelock is generally harder to detect because the processes
generally look like they are working to the outside operating system
whereas in deadlock the operating system generally knows when two
processes are waiting on a system-wide resource. Another problem is that
there are necessary conditions for livelock (i.e. deadlock fails to
occur) but not sufficient conditions â meaning there is no set of rules
where livelock has to occur. You must formally prove in a system by what
is known as an invariant. One has to enumerate each of the steps of a
system and if each of the steps eventually â after some finite number of
steps â leads to forward progress, the system fails to livelock. There
are even better systems that prove bounded waits; a system can only be
livelocked for at most <script type="math/tex">n</script> cycles which may be important for
something like stock exchanges.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="approaches-to-solving-livelock-and-deadlock" class="title-text">Approaches to Solving Livelock and Deadlock<a class="anchor title-text" href="#approaches-to-solving-livelock-and-deadlock">#</a>
</h2></div>















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Ignoring deadlock is the most obvious approach. Quite humorously, the
name for this approach is called the ostrich algorithm. Though there is
no apparent source, the idea for the algorithm comes from the concept of
an ostrich sticking its head in the sand. When the operating system
detects deadlock, it does nothing out of the ordinary, and any deadlock
usually goes away. An operating system preempts processes when stopping
them for context switches. The operating system can interrupt any system
call, potentially breaking a deadlock scenario. The OS also makes some
files read-only thus making the resource shareable. What the algorithm
refers to is that if there is an adversary that specifically crafts a
program â or equivalently a user who poorly writes a program â that the
OS deadlocks. For everyday life, this tends to be fine. When it is not
we can turn to the following method.</p>
<p>Deadlock detection allows the system to enter a deadlocked state. After
entering, the system uses the information to break deadlock. As an
example, consider multiple processes accessing files. The operating
system can keep track of all of the files/resources through file
descriptors at some level either abstracted through an API or directly.
If the operating system detects a directed cycle in the operating system
file descriptor table it may break one processâ hold through scheduling
for example and let the system proceed. Why this is a popular choice in
this realm is that there is no way of knowing which resources a program
will select without running the program. This is an extension of Riceâs
theorem (Rice <a href="#ref-rice" class="fancy-link wiki-link">#ref-rice</a>) that says that we
cannot know any semantic feature without running the program (semantic
meaning like what files it tries to open). So theoretically, it is
sound. The problem then gets introduced that we could reach a livelock
scenario if we preempt a set of resources again and again. The way
around this is mostly probabilistic. The operating system chooses a
random resource to break <code class="highlighter-rouge">hold-and-wait</code>. Now even though a user can
craft a program where breaking hold and wait on each resource will
result in a livelock, this doesnât happen as often on machines that run
programs in practice or the livelock that does happen happens for a
couple of cycles. These systems are good for products that need to
maintain a non-deadlocked state but can tolerate a small chance of
livelock for a short time.</p>
<h3 id="extra-bankers-algorithm" class="title-text">Extra: Bankerâs Algorithm</h3>
<p>We can start with a single resource Bankerâs Algorithm. Consider a
banker, who has a finite amount of money. With a finite amount of money,
she wants to make loans and eventually get her money back. Letâs say
that we have a set of <script type="math/tex">n</script> people where each of them has a set amount
or a limit <script type="math/tex">a_i</script> (<script type="math/tex">i</script> being the <script type="math/tex">i</script>th process) that they
need to obtain before they can do any work. The banker keeps track of
how much she has given to each person <script type="math/tex">l_i</script>. She maintains an amount
of money <script type="math/tex">p</script> with her, at all times. For people to request money,
they do the following: Consider the state of the system
<script type="math/tex">(A=\{a_1, a_2, ...\}, L_t=\{l_{t,1}, l_{t,2}, ...\}, p)</script> at time
<script type="math/tex">t</script>. A precondition is that we have <script type="math/tex">p â¥min(A)</script>, or we have
enough money to suit at least one person. Also, each person will work
for a finite period and give back our money.</p>
<ul>
  <li>
    <p>A person <script type="math/tex">j</script> requests <script type="math/tex">m</script> from me</p>

    <ul>
      <li>
        <p>if <script type="math/tex">% <![CDATA[
m < p %]]></script>, they are denied.</p>
      </li>
      <li>
        <p>if <script type="math/tex">m + l_j > a_i</script> they are denied</p>
      </li>
      <li>
        <p>Pretend we are in a new state
<script type="math/tex">(A, L_{t+1}=\{.., l_{t+1, j} = l_{t, j} + m, ...\}, p - m)</script>
where the process is granted the resource.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>if now person <script type="math/tex">j</script> is either satisfied (<script type="math/tex">l_{t+1,j} == a_j</script>)
or <script type="math/tex">min(a_i - l_{t+1, i}) â¤p</script>. In other words, we have enough
money to suit one other person. If either, consider the transaction
safe and give them the money.</p>
  </li>
</ul>
<p>Why does this work? Well at the start we are in a safe state â defined
by we have enough money to suit at least one person. Each of these
âloansâ results in a safe state. If we have exhausted our reserve, one
person is working and will give us money greater than or equal to our
previous âloanâ, thus putting us in a safe state again. Since we can
always make one additional move, the system can never deadlock. Now,
there is no guarantee that the system wonât livelock. If the process we
hope to request something never does, no work will be done â but not due
to deadlock. This analogy expands to higher orders of magnitude but
requires that either a process can do its work entirely or there exists
a process whose combination of resources can be satisfied, which makes
the algorithm a little more tricky (an additional for loop) but nothing
too bad. There are some notable downsides.</p>
<ul>
  <li>
    <p>The program first needs to know how much of each resource a process
needs. A lot of times that is impossible or the process requests the
wrong amount because the programmer didnât foresee it.</p>
  </li>
  <li>
    <p>The system could livelock.</p>
  </li>
  <li>
    <p>We know in most systems that resources vary, pipes and sockets for
example. This could mean that the runtime of the algorithm could be
slow for systems with millions of resources.</p>
  </li>
  <li>
    <p>Also, this canât keep track of the resources that come and go. A
process may delete a resource as a side effect or create a resource.
The algorithm assumes a static allocation and that each process
performs a non-destructive operation.</p>
  </li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="dining-philosophers" class="title-text">Dining Philosophers<a class="anchor title-text" href="#dining-philosophers">#</a>
</h2></div>

























<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>The Dining Philosophers problem is a classic synchronization problem.
Imagine we invite <script type="math/tex">n</script> (letâs say 6) philosophers to a meal. We will
sit them at a table with 6 chopsticks, one between each philosopher. A
philosopher alternates between wanting to eat or think. To eat the
philosopher must pick up the two chopsticks either side of their
position. The original problem required each philosopher to have two
forks, but one can eat with a single fork so we rule this out. However,
these chopsticks are shared with his neighbor.</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/deadlock/drawings/dining.png" alt="Dining
Philosophers"></p>
<p>Is it possible to design an efficient solution such that all
philosophers get to eat? Or, will some philosophers starve, never
obtaining a second chopstick? Or will all of them deadlock? For example,
imagine each guest picks up the chopstick on their left and then waits
for the chopstick on their right to be free. Oops - our philosophers
have deadlocked! Each philosopher is essentially the same, meaning that
each philosopher has the same instruction set based on the other
philosopher i.e. you canât tell every even philosopher to do one thing
and every odd philosopher to do another thing.</p>
<h3 id="failed-solutions" class="title-text">Failed Solutions</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">philosopher</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">forks</span><span class="p">){</span>
  <span class="n">info</span> <span class="n">phil_info</span> <span class="o">=</span> <span class="n">forks</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="n">left_fork</span> <span class="o">=</span> <span class="n">phil_info</span><span class="o">-&gt;</span><span class="n">left_fork</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="n">right_fork</span> <span class="o">=</span> <span class="n">phil_info</span><span class="o">-&gt;</span><span class="n">right_fork</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">phil_info</span><span class="o">-&gt;</span><span class="n">simulation</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">left_fork</span><span class="p">);</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">right_fork</span><span class="p">);</span>
    <span class="n">eat</span><span class="p">(</span><span class="n">left_fork</span><span class="p">,</span> <span class="n">right_fork</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">left_fork</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">right_fork</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This looks good but. What if everyone picks up their left fork and is
waiting on their right fork? We have deadlocked the program. It is
important to note that deadlock doesnât happen all the time and the
probability that this solution deadlock goes down as the number of
philosophers goes up. What is important to note is that eventually that
this solution will deadlock, letting threads starve which is bad. Here
is a simple resource allocation graph that shows how the system could be
deadlocked</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/deadlock/drawings/dining_naive.png" alt="Left right dining philosopher
cycle"></p>
<p>So now you are thinking about breaking one of the Coffman Conditions.
Letâs break Hold and Wait!</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">philosopher</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">forks</span><span class="p">){</span>
  <span class="n">info</span> <span class="n">phil_info</span> <span class="o">=</span> <span class="n">forks</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="n">left_fork</span> <span class="o">=</span> <span class="n">phil_info</span><span class="o">-&gt;</span><span class="n">left_fork</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="n">right_fork</span> <span class="o">=</span> <span class="n">phil_info</span><span class="o">-&gt;</span><span class="n">right_fork</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">phil_info</span><span class="o">-&gt;</span><span class="n">simulation</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">left_succeed</span> <span class="o">=</span> <span class="n">pthread_mutex_trylock</span><span class="p">(</span><span class="n">left_fork</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left_succeed</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sleep</span><span class="p">();</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">right_succeed</span> <span class="o">=</span> <span class="n">pthread_mutex_trylock</span><span class="p">(</span><span class="n">right_fork</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">right_succeed</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">left_fork</span><span class="p">);</span>
      <span class="n">sleep</span><span class="p">();</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">eat</span><span class="p">(</span><span class="n">left_fork</span><span class="p">,</span> <span class="n">right_fork</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">left_fork</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">right_fork</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now our philosopher picks up the left fork and tries to grab the right.
If itâs available, they eat. If itâs not available, they put the left
fork down and try again. No deadlock! But, there is a problem. What if
all the philosophers pick up their left at the same time, try to grab
their right, put their left down, pick up their left, try to grab their
right and so on. Here is what a time evolution of the system would look
like.</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/deadlock/drawings/dining_livelock.png" alt="Livelock
Failure"></p>
<p>We have now livelocked our solution! Our poor philosophers are still
starving, so letâs give them some proper solutions.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="viable-solutions" class="title-text">Viable Solutions<a class="anchor title-text" href="#viable-solutions">#</a>
</h2></div>























































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>The naive arbitrator solution has one arbitrator a mutex for example.
Have each of the philosophers ask the arbitrator for permission to eat
or trylock an arbitrator mutex. This solution allows one philosopher to
eat at a time. When they are done, another philosopher can ask for
permission to eat. This prevents deadlock because there is no circular
wait! No philosopher has to wait for any other philosopher. The
advanced arbitrator solution is to implement a class that determines if
the philosopherâs forks are in the arbitratorâs possession. If they are,
they give them to the philosopher, let him eat, and take the forks back.
This has the bonus of being able to have multiple philosophers eat at
the same time.</p>
<p>There are a lot of problems with these solutions. One is that they are
slow and have a single point of failure. Assuming that all the
philosophers are good-willed, the arbitrator needs to be fair. In
practical systems, the arbitrator tends to give forks to the same
processes because of scheduling or pseudo-randomness. Another important
thing to note is that this prevents deadlock for the entire system. But
in our model of dining philosophers, the philosopher has to release the
lock themselves. Then, you can consider the case of the malicious
philosopher (letâs say Descartes because of his Evil Demons) could hold
on to the arbitrator forever. He would make forward progress and the
system would make forward progress but there is no way of ensuring that
each process makes forward progress without assuming something about the
processes or having true preemption â meaning that a higher authority
(letâs say Steve Jobs) tells them to stop eating forcibly.</p>
<p><strong>(Optional) Proof:</strong><br>
The arbitrator solution doesnât deadlock</p>
<p>The proof is about as simple as it gets. Only one philosopher can
request resources at a time. There is no way to make a cycle in the
resource allocation graph with only one philosopher acting in pickup the
left then the right fork which is what we needed to show.</p>
<p><strong>(Optional) â </strong></p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/deadlock/drawings/dining_arbitrator.png" alt="Arbitrator
Diagram"></p>
<h3 id="leaving-the-table-stallings-solution" class="title-text">Leaving the Table (Stallingsâ Solution)</h3>
<p>Why does the first solution deadlock? Well, there are <script type="math/tex">n</script>
philosophers and <script type="math/tex">n</script> chopsticks. What if there is only 1 philosopher
at the table? Can we deadlock? No. How about 2 philosophers? 3? You can
see where this is going. Stallingsâ (Stallings
<a href="#ref-stalling" class="fancy-link wiki-link">#ref-stalling</a> P. 280) solution removes
philosophers from the table until deadlock is not possible â think about
what the magic number of philosophers at the table. The way to do this
in the actual system is through semaphores and letting a certain number
of philosophers through. This has the benefit that multiple philosophers
can be eating.</p>
<p>In the case that the philosophers arenât evil, this solution requires a
lot of time-consuming context switching. There is also no reliable way
to know the number of resources beforehand. In the dining philosophers
case, this is solved because everything is known but trying to specify
an operating system where a system doesnât know which file is going to
get opened by what process can lead to a faulty solution. And again
since semaphores are system constructs, they obey system timing clocks
which means that the same processes tend to get added back into the
queue again. Now if a philosopher becomes evil, then the problem becomes
that there is no preemption. A philosopher can eat for as long as they
want and the system will continue to function but that means the
fairness of this solution can be low in the worst case. This works best
with timeouts or forced context switches to ensure bounded wait times.</p>
<p><strong>(Optional) Proof:</strong><br>
Stallingsâ Solution Doesnât Deadlock. Letâs number the philosophers
<script type="math/tex">\{p_0, p_1, .., p_{n-1}\}</script> and the resources
<script type="math/tex">\{r_0, r_1, .., r_{n-1}\}</script>. A philosopher <script type="math/tex">p_i</script> needs resource
<script type="math/tex">r_{i-1 \mod n}</script> and <script type="math/tex">r_{i + 1 \mod n}</script>. Without loss of
generality, let us take <script type="math/tex">p_i</script> out of the picture. Each resource had
exactly two philosophers that could use it. Now resources
<script type="math/tex">r_{i-1 \mod n}</script> and <script type="math/tex">r_{i + 1 \mod n}</script> only have on philosopher
waiting on it. Even if hold and wait, no preemption, and mutual
exclusion or present, the resources can never enter a state where one
philosopher requests them and they are held by another philosopher
because only one philosopher can request them. Since there is no way to
generate a cycle otherwise, circular wait cannot hold. Since circular
wait cannot hold, deadlock cannot happen.<br>
<strong>(Optional) â </strong><br>
Here is a visualization of the worst-case. The system is about to
deadlock, but the approach resolves it.</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/deadlock/drawings/dining_stalling.png" alt="Stalling solution almost
deadlock"></p>
<h3 id="partial-ordering-dijkstras-solution" class="title-text">Partial Ordering (Dijkstraâs Solution)</h3>
<p>This is Dijkstraâs solution (Dijkstra,
<a href="#ref-EWD:EWD310" class="fancy-link wiki-link">#ref-EWD:EWD310</a> P. 20). He was the one to
propose this problem on an exam. Why does the first solution deadlock?
Dijkstra thought that the last philosopher who picks up his left fork
(causing the solution to deadlock) should pick up his right. He
accomplishes it by number the forks <script type="math/tex">1..n</script>, and tells each of the
philosophers to pick up his lower number fork. Letâs run through the
deadlock condition again. Everyone tries to pick up their lower number
fork first. Philosopher <script type="math/tex">1</script> gets fork <script type="math/tex">1</script>, Philosopher <script type="math/tex">2</script>
gets fork <script type="math/tex">2</script>, and so on until we get to Philosopher <script type="math/tex">n</script>. They
have to choose between fork <script type="math/tex">1</script> and <script type="math/tex">n</script>. fork <script type="math/tex">1</script> is already
held up by philosopher <script type="math/tex">1</script>, so they canât pick up that fork, meaning
he wonât pick up fork <script type="math/tex">n</script>. We have broken <code class="highlighter-rouge">circular wait</code>! Meaning
deadlock isnât possible.</p>
<p>Some problems are that an entity either needs to know the finite set of
resources in advance or be able to produce a consistent partial order
suck that circular wait cannot happen. This also implies that there
needs to be some entity, either the operating system or another process,
deciding on the number and all of the philosophers need to agree on the
number as new resources come in. As we have also seen with previous
solutions, this relies on context switching. This prioritizes
philosophers that have already eaten but can be made fairer by
introducing random sleeps and waits.</p>
<p><strong>(Optional) Proof:</strong><br>
Dijkstraâs Solution Doesnât Deadlock</p>
<p>The proof is similar to the previous proof. Letâs number the
philosophers <script type="math/tex">\{p_0, p_1, .., p_{n-1}\}</script> and the resources
<script type="math/tex">\{r_0, r_1, .., r_{n-1}\}</script>. A philosopher <script type="math/tex">p_i</script> needs resource
<script type="math/tex">r_{i-1 \mod n}</script> and <script type="math/tex">r_{i + 1 \mod n}</script>. Each philosopher will
grab <script type="math/tex">r_{i-1 \mod n}</script> then <script type="math/tex">r_{i + 1 \mod n}</script> but the last
philosopher will grab in the reverse order. Even if hold and wait, no
preemption, and mutual exclusion or present. Since the last philosopher
will grab <script type="math/tex">r_{n-1}</script> then <script type="math/tex">r_0</script> there are two cases either the
philosopher has the first lock or the philosopher doesnât.</p>
<p>If the last philosopher <script type="math/tex">p_{n-1}</script> holds the first lock meaning the
previous philosopher <script type="math/tex">p_{n-2}</script> is waiting on <script type="math/tex">r_{n-1}</script> meaning
<script type="math/tex">r_{n-2}</script> is available. Since no other blockers, the philosopher
previous <script type="math/tex">p_{n-3}</script> will grab her first lock. This is now a reduction
to the previous proof of stalling because we now have <script type="math/tex">n</script> resources
but only <script type="math/tex">n-1</script> philosophers, meaning this cannot deadlock.</p>
<p>If the philosopher doesnât obtain that first lock, then we have a
reduction to Stallingâs proof above because now have <script type="math/tex">n-1</script>
philosophers vying for <script type="math/tex">n</script> resources. Since we canât reach deadlock
in either case, this solution cannot deadlock which is what we needed to
show.</p>
<p><strong>(Optional) â </strong></p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/deadlock/drawings/dining_partial.png" alt="Stalling solution partial
deadlock"></p>
<h3 id="extra-cleandirty-forks-chandymisra-solution" class="title-text">Extra: Clean/Dirty Forks (Chandy/Misra Solution)</h3>
<p>There are many more advanced solutions. One such solution is by Chandy
and Misra (Chandy and Misra
<a href="#ref-Chandy:1984:DPP:1780.1804" class="fancy-link wiki-link">#ref-Chandy:1984:DPP:1780.1804</a>).
This is not a true solution to the dining philosophers problem because
it has the requirement that philosophers can speak to each other. It is
a solution that ensures fairness for some notion of fairness. In
essence, it defines a series of rounds that a philosopher must eat in a
given round before going to the next one.</p>
<p>We wonât detail the proof here because it is a little more involved, but
feel free to read more.</p>
<h3 id="extra-actor-model" class="title-text">Extra: Actor Model</h3>
<p>The actor model is another form of synchronization that doesnât have to
do anything with negotiating locks or waiting. The idea is simple. Each
actor can either perform work, create more actors, send messages, or
respond to messages. Any time an actor needs something from another
actor, it sends a message. Most importantly, an actor is only
responsible for one thing. If we were implementing a real-world
application, we may have an actor that handles the database, one that
handles the incoming connections, one that services the connections,
etc. These actors would pass messages to each other like âthere is a new
connectionâ from the incoming connection actor to the servicing actor.
The servicing actor may send a data request message to the database
actor and a data response message comes back.</p>
<p>While this seems like the perfect solution there are drawbacks. The
first is the actual library of communication needs to be synchronized.
If you donât have a framework that does this already â like the Message
Passing Interface or MPI for High-Performance Computing â then the
framework will have to be built and would most likely be as much work to
build efficiently compared to direct synchronization. Also, the messages
now encounter additional overhead for serializing and deserializing or
at the least. And a final drawback is that an actor could take an
arbitrarily long time to respond to a message, spurring the need for
shadow actors who service the same job.</p>
<p>As mentioned, there are frameworks like
<a href="https://en.wikipedia.org/wiki/Message_Passing_Interface" class="fancy-link wiki-link">https://en.wikipedia.org/wiki/Message_Passing_Interface</a>
that is somewhat based on the actor model and allows distributed systems
in high-performance computing to work effectively, but your mileage may
vary If you want to read further on the model, feel free to glance over
the Wikipedia page listed below.
<a href="https://en.wikipedia.org/wiki/Actor_model" class="fancy-link wiki-link">https://en.wikipedia.org/wiki/Actor_model</a></p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="topics" class="title-text">Topics<a class="anchor title-text" href="#topics">#</a>
</h2></div>



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><ul>
  <li>
    <p>Coffman Conditions</p>
  </li>
  <li>
    <p>Resource Allocation Graphs</p>
  </li>
  <li>
    <p>Dining Philosophers</p>
  </li>
  <li>
    <p>Failed DP Solutions</p>
  </li>
  <li>
    <p>Livelocking DP Solutions</p>
  </li>
  <li>
    <p>Working DP Solutions:
Benefits/Drawbacks</p>
  </li>
  <li>
    <p><a href="http://adit.io/posts/2013-05-11-The-Dining-Philosophers-Problem-With-Ron-Swanson.html" class="fancy-link wiki-link">http://adit.io/posts/2013-05-11-The-Dining-Philosophers-Problem-With-Ron-Swanson.html</a></p>
  </li>
</ul></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="questions" class="title-text">Questions<a class="anchor title-text" href="#questions">#</a>
</h2></div>






<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<ul>
  <li>
    <p>What are the Coffman conditions?</p>
  </li>
  <li>
    <p>What does each of the Coffman conditions mean? Define each one.</p>
  </li>
  <li>
    <p>Give a real-life example of breaking each Coffman condition in turn.
A situation to consider: Painters, Paint, Paint Brushes etc. How
would you assure that work would get done?</p>
  </li>
  <li>
    <p>Which Coffman condition is unsatisfied in the following snippet?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// Get both locks or none</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">pthread_mutex_trylock</span><span class="p">(</span> <span class="n">b</span> <span class="p">))</span> <span class="p">{</span> <span class="cm">/* failure */</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>The following calls are made</p>

    <div class="highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>// Thread 1
pthread_mutex_lock(m1) // success
pthread_mutex_lock(m2) // blocks
    
// Thread 2
pthread_mutex_lock(m2) // success
pthread_mutex_lock(m1) // blocks
</code></pre></div>    </div>

    <p>What happens and why? What happens if a third thread calls
<code class="highlighter-rouge">pthread_mutex_lock(m1)</code> ?</p>
  </li>
  <li>
    <p>How many processes are blocked? As usual, assume that a process can
complete if it can acquire all of the resources listed below.</p>

    <ul>
      <li>
        <p>P1 acquires R1</p>
      </li>
      <li>
        <p>P2 acquires R2</p>
      </li>
      <li>
        <p>P1 acquires R3</p>
      </li>
      <li>
        <p>P2 waits for R3</p>
      </li>
      <li>
        <p>P3 acquires R5</p>
      </li>
      <li>
        <p>P1 waits for R4</p>
      </li>
      <li>
        <p>P3 waits for R1</p>
      </li>
      <li>
        <p>P4 waits for R5</p>
      </li>
      <li>
        <p>P5 waits for R1</p>
      </li>
    </ul>
  </li>
</ul>
<p>Draw out the resource graph!</p>
<div id="refs" class="references">

<div id="ref-Chandy:1984:DPP:1780.1804">

Chandy, K. M., and J. Misra. 1984. âThe Drinking Philosophers Problem.â
*ACM Trans. Program. Lang. Syst.* 6 (4): 632â46.
<a href="https://doi.org/10.1145/1780.1804" class="fancy-link wiki-link">https://doi.org/10.1145/1780.1804</a>.

</div>

<div id="ref-coffman1971system">

Coffman, Edward G, Melanie Elphick, and Arie Shoshani. 1971. âSystem
Deadlocks.â *ACM Computing Surveys (CSUR)* 3 (2): 67â78.

</div>

<div id="ref-EWD:EWD310">

Dijkstra, Edsger W. n.d. âHierarchical Ordering of Sequential
Processes.â
<a href="http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD310.PDF" class="fancy-link wiki-link">http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD310.PDF</a>.

</div>

<div id="ref-rice">

Rice, H. G. 1953. âClasses of Recursively Enumerable Sets and Their
Decision Problems.â *Transactions of the American Mathematical Society*
74 (2): 358â66.
<a href="http://www.jstor.org/stable/1990888" class="fancy-link wiki-link">http://www.jstor.org/stable/1990888</a>.

</div>

<div id="ref-silberschatz2006operating">

Silberschatz, A., P.B. Galvin, and G. Gagne. 2006. *OPERATING System
Principles, 7TH Ed*. Wiley Student Ed. Wiley India Pvt. Limited.
<a href="https://books.google.com/books?id=WjvX0HmVTlMC" class="fancy-link wiki-link">https://books.google.com/books?id=WjvX0HmVTlMC</a>.

</div>

<div id="ref-stalling">

Stallings, William. 2011. *Operating Systems: Internals and Design
Principles 7th Ed. By Stallings (International Economy Edition)*. PE.
<a href="https://www.amazon.com/Operating-Systems-Internals-Principles-International/dp/9332518807?SubscriptionId=0JYN1NVW651KCA56C102&amp;tag=techkie-20&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=9332518807" class="fancy-link wiki-link">https://www.amazon.com/Operating-Systems-Internals-Principles-International/dp/9332518807?SubscriptionId=0JYN1NVW651KCA56C102&amp;tag=techkie-20&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=9332518807</a>.

</div>

</div>
</div></div></div>
</div></div>
</div>
          
          <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_coursebook/Deadlock.md";
  </script>
  <!-- Mathjax takes a while to load so do a lazy load to so we can get accessibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>

<!-- Bring in JQuery and Bootstrap -->
<script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" crossorigin="anonymous"></script>

<footer class="">

<!-- Add another container at the bottom so there is some space there -->
<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>

<!-- Mirrored from cs241.cs.illinois.edu/coursebook/Deadlock by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 17 Dec 2019 18:37:32 GMT -->
</html>
