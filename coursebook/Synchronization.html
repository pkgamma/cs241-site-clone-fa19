<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from cs241.cs.illinois.edu/coursebook/Synchronization by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 17 Dec 2019 18:37:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">

  <!-- If for some reason you are using IE, use edge -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- So bootstrap isn't horrible, set the width -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" type="image/png" href="../images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="../images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="../images/favicons/manifest.json">
  <link rel="mask-icon" href="../images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>CS 241 Â· Synchronization</title>

  <!-- Reference a CDN so this is properly cached in the browser forever. Unless they clean out the
       Cache this will incur no load time. Ideally we should put a security checksum but that breaks
       Firefox development sometimes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">

  <!-- Asynchronously load the code style sheet because we want everything loaded as fast as possible
       Also tag with ?v=time to bust the cache of any browser so updates appear -->
  <style rel="stylesheet" type="text/css">.highlight table td{padding:5px}.highlight table pre{margin:0}.highlight,.highlight .w{color:#93a1a1;background-color:#002b36}.highlight .err{color:#002b36;background-color:#dc322f}.highlight .c,.highlight .cd,.highlight .cm,.highlight .c1,.highlight .cs{color:#657b83}.highlight .cp{color:#b58900}.highlight .nt{color:#b58900}.highlight .o,.highlight .ow{color:#93a1a1}.highlight .p,.highlight .pi{color:#93a1a1}.highlight .gi{color:#859900}.highlight .gd{color:#dc322f}.highlight .gh{color:#268bd2;background-color:#002b36;font-weight:bold}.highlight .k,.highlight .kn,.highlight .kp,.highlight .kr,.highlight .kv{color:#6c71c4}.highlight .kc{color:#cb4b16}.highlight .kt{color:#cb4b16}.highlight .kd{color:#cb4b16}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .sh,.highlight .sx,.highlight .s1{color:#859900}.highlight .sr{color:#2aa198}.highlight .si{color:#d33682}.highlight .se{color:#d33682}.highlight .nn{color:#b58900}.highlight .nc{color:#b58900}.highlight .no{color:#b58900}.highlight .na{color:#268bd2}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .il,.highlight .mo,.highlight .mb,.highlight .mx{color:#859900}.highlight .ss{color:#859900}
/*# sourceMappingURL=/assets/source-maps/code-style.css.map */
/*# sourceURL=css/code-style.css */
</style>
  <style rel="stylesheet" type="text/css">:root{--color-primary: hsl(207, 59%, 43%);--color-secondary: hsl(207, 70%, 53%);--color-emphasis: hsl(204, 100%, 42%);--color-text: hsl(0, 0%, 0%);--color-translucent: hsla(0, 0%, 0%, 0.3);--color-pale-white: hsla(240, 8%, 95%)}body{padding-top:50px;font-family:Roboto, Helvetica, Arial, sans-serif;background-color:var(--color-pale-white);color:var(--color-text);padding-bottom:50px}@media (min-width: 768px) and (max-width: 991px){body{padding-top:100px}}.navbar{background-color:var(--color-primary);border-color:var(--color-secondary);border:0px;border-top:none;box-shadow:none;margin-bottom:0}.navbar-default .navbar-brand{color:var(--color-pale-white) !important;font-weight:bold}.navbar-default .navbar-nav>li>a{color:var(--color-pale-white) !important}.navbar-collapse{border-top:0px !important;box-shadow:none}.navbar-brand:hover{color:var(--color-navbar-text) !important}.github-link{display:inline-block;vertical-align:middle;margin-left:0.5em;text-indent:-9999px;width:32px;height:32px;background-image:url(NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgNjQgNjQiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDY0IDY0IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBmaWxsPSIjMTgxNjE2IiBkPSJNMzIuNiwzLjRDMTYuMywzLjQsMywxNi43LDMsMzMuMWMwLDEzLjEsOC41LDI0LjIsMjAuMywyOC4xDQoJYzEuNSwwLjMsMi0wLjYsMi0xLjRjMC0wLjcsMC0yLjYsMC01Yy04LjIsMS44LTEwLTQtMTAtNGMtMS4zLTMuNC0zLjMtNC4zLTMuMy00LjNjLTIuNy0xLjgsMC4yLTEuOCwwLjItMS44YzMsMC4yLDQuNSwzLjEsNC41LDMuMQ0KCWMyLjYsNC41LDYuOSwzLjIsOC42LDIuNWMwLjMtMS45LDEtMy4yLDEuOS00Yy02LjYtMC43LTEzLjUtMy4zLTEzLjUtMTQuNmMwLTMuMiwxLjItNS45LDMtNy45Yy0wLjMtMC43LTEuMy0zLjgsMC4zLTcuOA0KCWMwLDAsMi41LTAuOCw4LjEsM2MyLjQtMC43LDQuOS0xLDcuNC0xYzIuNSwwLDUsMC4zLDcuNCwxYzUuNy0zLjgsOC4xLTMsOC4xLTNjMS42LDQuMSwwLjYsNy4xLDAuMyw3LjhjMS45LDIuMSwzLDQuNywzLDcuOQ0KCWMwLDExLjQtNi45LDEzLjktMTMuNSwxNC42YzEuMSwwLjksMiwyLjcsMiw1LjVjMCw0LDAsNy4yLDAsOC4xYzAsMC44LDAuNSwxLjcsMiwxLjRjMTEuOC0zLjksMjAuMi0xNSwyMC4yLTI4LjENCglDNjIuMiwxNi43LDQ5LDMuNCwzMi42LDMuNHoiLz4NCjwvc3ZnPg0K)}h1{padding-bottom:20px;font-size:48px}h2{padding-top:50px;margin-top:-20px}.navbar-nav,.navbar-nav>ul{margin:0}@media (max-width: 767px){h1{font-size:36px}h2{font-size:22px}p,li{font-size:12px}}.popover{background-color:black;color:black;display:block}.popover-title{background-color:black;color:black;font-size:12px;text-align:center;border-bottom:0px}.popover-title a{color:white;cursor:pointer}.popover-content{background-color:black;padding:0px}.popover.top>.arrow:after{border-top-color:black}table{width:100%}.anchor{display:none;padding-left:5px}.title-text:hover>.anchor{display:inline}.day{height:300px;margin-bottom:20px;width:100%;background-color:#fff;border-radius:3px}.day h1{color:#f1f1f3}.day-summary,.day-resources{color:#000}.day-resources{position:absolute;bottom:20px}.day-summary{position:absolute;top:75px}.day-title-text h3{margin:0px}.day-title{padding-top:5px;padding-bottom:5px;border-radius:3px;height:70px}.schedule-container{margin-left:20px;margin-right:20px}ul.toc{list-style:none;padding-left:1em}h1,h2,h3{color:var(--color-secondary)}.announcement-card{background-color:var(--color-pale-white);border-radius:5px}.annoucement-title{margin-top:5px}.day-title-h3{color:var(--color-pale-white)}img:not(.emoji){max-height:80vh;display:inline-block;margin:auto;max-width:100%}.img-paragraph{display:grid}.hidden{display:none !important}.loader,.loader:before,.loader:after{border-radius:50%}.loader{color:var(--color-pale-white);font-size:11px;text-indent:-99999em;margin:55px auto;position:relative;width:10em;height:10em;box-shadow:inset 0 0 0 1em;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0)}.loader:before,.loader:after{position:absolute;content:''}.loader:before{width:5.2em;height:10.2em;background:#0dc5c1;border-radius:10.2em 0 0 10.2em;top:-0.1em;left:-0.1em;-webkit-transform-origin:5.2em 5.1em;transform-origin:5.2em 5.1em;-webkit-animation:load2 2s infinite ease 1.5s;animation:load2 2s infinite ease 1.5s}.loader:after{width:5.2em;height:10.2em;background:#0dc5c1;border-radius:0 10.2em 10.2em 0;top:-0.1em;left:5.1em;-webkit-transform-origin:0px 5.1em;transform-origin:0px 5.1em;-webkit-animation:load2 2s infinite ease;animation:load2 2s infinite ease}@-webkit-keyframes load2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes load2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.anchor{text-decoration:none}.anchor:hover{text-decoration:none}.fancy-link{text-decoration:none !important;color:var(--color-emphasis);display:inline-block;position:relative;padding-bottom:0px}.fancy-link:after{content:'';display:block;margin:auto;height:1px;width:0px;background:transparent;transition:width .3s ease, background-color .3s ease}.fancy-link:hover:after{width:100%;background:var(--color-emphasis)}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.navbar-toggle{border-width:0px}.navbar-default .navbar-toggle .icon-bar{background-color:var(--color-pale-white)}.navbar-brand.small{display:none}@media (max-width: 767px){.navbar-brand.normal{display:none}.navbar-brand.small{display:inline-block}}.speaker-wrapper{float:right}.speaker{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAQAAABpN6lAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAEZ0FNQQAAsY58+1GTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAfRSURBVHja7Z1viBzlHce/v2f+7OztbdL2FAumvsgl6okYCCrWPxDoq9BUKG05CuKLNtK+KCnaQtM/oIhR0BLsq5pUUlIq9oVgtW0gbWkj1IIttSBiKKJtQ9Ge5Pb2bndvZ3Zmnp8vZnZ2Zm42OZKZu5ndZ4a7g/u7v8/z/X2f3/N7nr0lxnRfAgqAAqAAKAAKgAKgACgACoACoAAoAAqAAqAAKAAKgAKgACgACoACoAAoAArAlVwObgNBg4CWuvXwNmDAgAkDhMdwU/he4F58H4Q7cBSEGo7h5ujr9+B7IAiIO8WjtO9HOQPQKzNUd+EYbrOuve8I5JSlgAYLWKRTtJe7M/sPzEyZAgQu4twjdIQk+tAhbKM2XQC0xnuPn1/UbfihYA0QAJ4KABbE9d4z2gGzywwABCJY0OFPBQAD525dflYsiA6FViUhCCa0PG1QL2vmE+jg2WP6NUaXwCEAAhH0fI27lAAINrzD3tGaLvoUTVUEDRpAUzAL1I3nfrj2NdMVjgjGHQDAgS4muxAiCGDOfqp3SO8JSRjeCD2Acv+LJQMgYe/BcdxudIlFOOJxBYhJB/De3e/+uHaD1iEQNFBC9BMOICh41x/lhtELxj6pAAYX4AClAaDhIl57RDsiJNnD4EcAEAKYWAUQtMb7j7+zWLfJF1HwGggUhcyQk6oAC+J69xn9QL0rGBDQwvBFzAE4LI4weQAMnLv14rNiQeuIsJUSvymllAlTQFjwPmnMGd2R7EXYUaIIAMfeTxAAgg3/sHu0pov+SPLJ8AkEBkEWNP7bCqD2yZPf6T1oupqDKOBh+CI2/gGCok61bxeAa+jz8oHVBb2vSYrGnlLhj0a8uEP9ekG/dR47slft3KRd2I+76Aby9N6o4BnN/oTkGkBGHsAVAXAPjtIeEJgSGc9BQDpZEMLBusYUK3lEKvzRupdQ5JM6cgfAd+MUzcAZhR//SCCgT0xhkUMbwtfCNWHa8IqaCXIGYGtLh9GkDiVCj4MYNjjisqfMkR8GzKH8uZAkyFsBDXkj+hQFG8h3uJyhSAUBBhHpgGJ1/+i7UWDuFwWgJoygfh/O4CIa9ySAUeAiUkS89qeEBrgSJkggmIgmsHQwIkRCCQRJ1x+lwMj54ylQdgA6TEHxOVyksh+ZGqBU3o98n1PZzyUHoMEQseAQG9F4+Ehkfbrzlzm3FFYQ5esBBI0oWcyMgzAueI6lTbIAkvluCxdVByTlnQSQhJE96hyr/TlshBRZDOvFhJ9la2kdpCe9YNWXXgBzzAorUAghNf6XAhCfHuOhyQ1lkARDVmctME4BWRjG2132Z7gKADZmOWUWxMm8zwovWQFUZzUYZXbW+G8Mcfx5h2QVWI21QMzZKeX7V7XGrFhDZFMB0WWD40QxXGEAnKkB3hSmolcDYmtG+2p+klN+UPaOUPhQCTJGl6/qt8lUfVD6FBiFL0EQV/zQCTJMH1mYPkUxkudc+nicURZXRAEjp+ccYBbXDlHH5RWAQmaBPMQ/rhguvwKoqKqtGtvjku1gSygYNZGTArgiHqDNdPa9bVsbC9g87mJQ5KwAnZ789TsL/9ldc4Otz42rQWLBgomvxFeqUAdo+z7840+ePviXva6ZdbKXeGCtWqt1EnVXk5cPKR52FUphCQ80v3Li5fUdUstuAzC9O/vGZ/6099zN7WbD1eR2GyFxnn5iook5zKEJc8yptqD940N787qTd77wWb9muZtRQJAEA32udf7Bnf+FEzyBpmwKYPhw0IUBhgV9DIDgHIzc/+FzLx86/+0vXfj0rEPYvqsIAIwBrDHP7AjOQekwYEI/dH73yW985fVbmg4xbUIB1fCAPnw4MKCNAUDQYcCCBQv1W5Ze+fl3D52+ty51P6s9Gt8jrkZX2AfDxyA86DsuBXSYqGMGs2h8Cqde2rN07Au2WXM31x4p+3I42MZxL9EKDpKgjz4cuGjC+sGfFy5+68tL1844xRyG3Op+wOUGyocHF4PwzUMTjS++tXv564v/uHHWEZydApO1HGb4cLGOLtpoYQVrkPs++N3zi3/tGq5W7JmgLekIbRrCABI+PHjw0byu8+Kv9nz09EHfMF3O2CWubFv8ksngoo81rKCFNmxyn/j96dM7Vnu1ccuhyesISbiw0cEKltFGD/Krb545sfDvniVpuCXOhS6It78lxvBgo4tVLGMFHfAdF87+7P6/r5u+2IppsAw9wcANelhFCytYhber/dIvHz7jYLAFDlWWpqiPAdaxhhZaaMMx3ONnTrzQ6K2bPDVtcRkZYugGD/3tNyfn/9e3eCoUMHQDBx20QzeQ971/9sTn/mnXpJhsD0giGLpBC2vw5luv/uKbfxiI4sqj8m2MjAxxGW0MZuyfvnr8RdMemEE/afIBDN2ggzZaaKMP/+HXX3l+1/8HdTY8l3JuDWqPoZQXQ8KHH/67FGO+dfBfF2pLjQd+e/8bYgA3v3ygEr/IigYTFmaxA5/ALAzQKu38AB9hBevl7AkW4QYyVIKHWeg7HfjRk8imAADgQ4YIPLioQcKBmy+Csv8nKQ67jB4GsMBwMMhP/mX3gOgxQsBADToIXt4IqBKvNDXcTQgWTrmmAFXmpbYo6prztKXA1CyGFAAFQAFQABQABUABUAAUAAVAAVAAFAAFQAFQABQABWALro8B0vUmf5f9kKEAAAAASUVORK5CYII=");background-size:cover;height:40px;width:40px;margin-top:5px}pre{color:var(--color-pale-white);background-color:var(--color-text);border:inherit}code{color:var(--color-pale-white)}.code-copy{float:right;right:0px;display:none;background-color:var(--color-text);padding:5px 5px 5px 5px;border-radius:3px;cursor:pointer}pre code{display:block}pre:hover>*>.code-copy{display:inline}.code-copy-textarea{position:absolute;left:-9999px;top:-9999px}pre.highlight{margin-bottom:-10px;padding-bottom:0px}.highlighter-rouge{background-color:#DFDFDF;color:#151515;border-radius:5px;padding-top:4px}.highlight{background-color:#151515;border:0px;color:#F2F2F4}div.highlighter-rouge,figure.highlighter-rouge{background-color:#151515;color:#D7D7D7;padding-bottom:1.5em;margin-bottom:0.65em}.fancy-link code{color:#337ab7}.fancy-link:hover code{color:#23527c}.fancy-link:hover:after code{background-color:#337ab7}.table>tbody>tr>td,table>tbody>tr>td,.table>tbody>tr>th,table>tbody>tr>th,.table>tfoot>tr>td,table>tfoot>tr>td,.table>tfoot>tr>th,table>tfoot>tr>th,.table>thead>tr>td,table>thead>tr>td,.table>thead>tr>th,table>thead>tr>th{border-top:0px}.table,table{margin-left:40px;width:75%}.search-icon-div{width:initial;padding-left:10px;background-color:white;height:34px;border-radius:3px 0px 0px 3px}.glyphicon-search{font-size:32px;top:0px;color:#2C72AD}.search{border-radius:0px 3px 3px 0px;border:0px;outline:none;box-shadow:none}.no-gutter>[class*='col-']{padding-right:0;padding-left:0}.result-link{font-size:24px;text-decoration:underline}.result-div{padding-bottom:12px}.highlight-result{background-color:yellow;border-radius:3px;color:black;padding-left:2px;padding-right:2px}tbody tr:nth-child(odd){background-color:#DDD;border-radius:20px}html.hacker,body.hacker,header.hacker,nav.hacker,:not(.card-staff)>*>div:not(.card-staff).hacker,table.hacker,pre.hacker,span.hacker,:not(.card-staff)>a.hacker,p.hacker,h1.hacker,h2.hacker,h3.hacker,h4.hacker,h5.hacker,h6.hacker{color:white !important;font-family:monospace !important;background-color:black !important}h1.hacker,h2.hacker,h3.hacker,h4.hacker,h5.hacker,h6.hacker{color:#20C20E !important}ul.hacker{list-style-type:square}pre.hacker{border-color:white;border-radius:0}.toc.hacker{border-left-width:0}.content .highlighter-rouge.hacker{font-weight:bold;background-color:black}.pad.hacker{padding:0}a.hacker{color:#20C20E}tbody tr:nth-child(odd).hacker{background-color:inherit}body.hacker .day,body.hacker .announcement-card{background-color:#151515}body.hacker .announcement{color:white !important}#tuxlink img.hacker{-ms-interpolation-mode:nearest-neighbor;image-rendering:pixelated}.apply-button{border:none;background-color:white;padding:10px 20px 10px 20px;font-size:36px;border-radius:5px;box-shadow:5px 5px gray;margin:10px auto 10px auto;display:block;transition:background-color 0.5s ease}.apply-button:hover{background-color:var(--color-primary)}li.navbar-subitem{float:left;overflow:hidden;width:100%}.navbar-item,.navbar-subitem{color:var(--color-navbar-text);text-align:center;font-family:'Roboto', sans-serif}li.navbar-item:hover,li.navbar-subitem:hover{background-color:white}li.navbar-item:hover>a,li.navbar-subitem:hover>a{color:var(--color-primary) !important}.subitem-container{display:none;position:absolute;min-width:8vw;background-color:var(--color-primary);box-shadow:0px 8px 16px 0px var(--color-translucent);z-index:1;width:100%}.navbar-item:hover .subitem-container{display:block}.staff{width:100%}.flexbox-item div.staff-image{width:18vh;height:18vh;overflow:hidden;background-size:cover;padding:0;border-radius:50%}.flexbox-item:hover div.staff-image{box-shadow:0 4px 12px 0 var(--color-translucent),0 6px 20px 0 var(--color-translucent)}.staff-name{bottom:0px;width:100%;text-align:center;font-weight:100;padding-top:2vh;color:var(--color-secondary-emphasis)}.heading{text-align:center;font-family:Roboto, Helvetica, sans-serif;font-size:3em;padding:1em;padding:0}section.center{text-align:center;padding-left:3vw;padding-right:3vw;padding-bottom:0;padding-top:0}main{text-align:center;margin:0;padding:0;background-color:white}.card-body{background-color:var(--color-pale-white);padding:2vh;display:block}.card-body.course-heading{background-color:rgba(72,105,255,0.945)}.card-body.card-body.course-heading h1{color:white}.card-body.course-information{background-color:white}h2{font-weight:200}section.flexbox{display:flex;justify-content:center;margin:auto;flex-wrap:wrap;width:90vw}.flexbox-item{display:inline-block;padding:2vh;margin:2vh}img.logo{width:2vw;height:3vw;margin:2vh}@media (max-width: 480px){.flexbox-item div.staff-image{width:18vh;height:18vh}img.logo{width:10vw;height:8vh}.staff-name{font-size:0.75em}}.infrastructure-links{margin:auto;text-align:center;display:block}.gallery{display:flex;justify-content:center;margin:auto;padding:5vw;flex-wrap:wrap;width:100vw}.staff{width:100%}.staff-container{margin:2vh}.staff-container div.staff-image{width:24vh;height:24vh;overflow:hidden;background-size:cover;padding:0;border-radius:50%}.staff-container:hover div.staff-image{box-shadow:0 4px 12px 0 var(--color-translucent),0 6px 20px 0 var(--color-translucent)}.staff-name{bottom:0px;width:100%;text-align:center;font-size:1.5em;padding-top:1vh;color:var(--color-emphasis)}.heading{text-align:center}section.center{text-align:center;padding-left:3vw;padding-right:3vw;padding-bottom:0;padding-top:0}@media only screen and (max-width: 480px){.staff-container div.staff-image{width:20vh;height:20vh}.staff-name{font-size:1.25em}}.latest-mp{background-color:rgba(16,213,147,0.85)}.latest-lab{background-color:rgba(255,102,42,0.85)}.latest-assignments section.flexbox-item{border-radius:4%}
/*# sourceMappingURL=/assets/source-maps/main.css.map */
/*# sourceURL=css/main.css */
</style>

  <meta property="og:locale" content="en_US">
  
  
  <meta property="og:title" content="Synchronization" />
  
  
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://cs241.cs.illinois.edu" />
  
  
  <meta property="og:description" content=""Webpage for CS 241: System Programming at the University of Illinois at Urbana-Champaign. All documentation and information about the course can be found here."
" />
  

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <!-- Navigation button as html so we don't have to resize images -->
      <button
        type="button"
        class="navbar-toggle collapsed"
        data-toggle="collapse"
        data-target=".navbar-collapse"
        aria-expanded="false"
        aria-controls="navbar"
      >
        <!-- Hamburger Navigation bar on small -->
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <!-- Full title on laptop -->
      <a class="navbar-brand navbar-item normal" href="../index.html">
             <span>CS 241: System Programming</span> 
      </a>

      <!-- Smaller on mobile-->
      <a class="navbar-brand navbar-item small" href="../index.html">
          <span>CS 241</span>
      </a>
    </div>

    <!-- Finally generate what is in the navbar -->
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
        <li class="navbar-item">
          <a href="../assignments.html">Assignments</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../quiz_topics.html">Quizzes</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../grades.html">Grades</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../schedule.html">Schedule</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="../lectures.html">Lectures</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../syllabus.html">Syllabus</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../staff.html">Staff</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="../staff_hall_of_fame.html">Staff Hall of Fame</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../resources.html">Resources</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="../peer_tutoring.html">Peer Tutoring</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="index.html">Coursebook</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="../honors.html">Honors</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
      </ul>
    </div>
  </div>
  <!-- Fonts -->
  <link
    href="https://fonts.googleapis.com/css?family=Roboto"
    rel="stylesheet"
  />
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            
            
            
            <h1>
              Synchronization

              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
            
          </div></div></div>
        </div></div>
      </div>
      
      <div id="content">
          <div class="wrapper">

</div>
          <div class="wrapper">
<ul>
  <li>
<a href="#synchronization" class="fancy-link wiki-link">Synchronization</a>
    <ul>
      <li>
<a href="#mutex" class="fancy-link wiki-link">Mutex</a>
        <ul>
          <li><a href="#mutex-lifetime" class="fancy-link wiki-link">Mutex Lifetime</a></li>
          <li><a href="#mutex-usages" class="fancy-link wiki-link">Mutex Usages</a></li>
          <li><a href="#mutex-implementation" class="fancy-link wiki-link">Mutex Implementation</a></li>
          <li><a href="#extra-implementing-a-mutex-with-hardware" class="fancy-link wiki-link">Extra: Implementing a Mutex with
hardware</a></li>
          <li><a href="#semaphore" class="fancy-link wiki-link">Semaphore</a></li>
        </ul>
      </li>
      <li>
<a href="#condition-variables" class="fancy-link wiki-link">Condition Variables</a>
        <ul>
          <li><a href="#extra-why-do-condition-variables-also-need-a-mutex" class="fancy-link wiki-link">Extra: Why do Condition Variables also need a
mutex?</a></li>
          <li><a href="#condition-wait-example" class="fancy-link wiki-link">Condition Wait Example</a></li>
        </ul>
      </li>
      <li>
<a href="#thread-safe-data-structures" class="fancy-link wiki-link">Thread-Safe Data Structures</a>
        <ul>
          <li><a href="#using-semaphores" class="fancy-link wiki-link">Using Semaphores</a></li>
        </ul>
      </li>
      <li>
<a href="#software-solutions-to-the-critical-section" class="fancy-link wiki-link">Software Solutions to the Critical
Section</a>
        <ul>
          <li><a href="#naive-solutions" class="fancy-link wiki-link">Naive Solutions</a></li>
          <li><a href="#turn-based-solutions" class="fancy-link wiki-link">Turn-based solutions</a></li>
          <li><a href="#turn-and-flag-solutions" class="fancy-link wiki-link">Turn and Flag solutions</a></li>
        </ul>
      </li>
      <li>
<a href="#working-solutions" class="fancy-link wiki-link">Working Solutions</a>
        <ul>
          <li><a href="#petersons-solution" class="fancy-link wiki-link">Petersonâs Solution</a></li>
          <li><a href="#extra-implementing-software-mutex" class="fancy-link wiki-link">Extra: Implementing Software
Mutex</a></li>
        </ul>
      </li>
      <li>
<a href="#implementing-counting-semaphore" class="fancy-link wiki-link">Implementing Counting
Semaphore</a>
        <ul>
          <li><a href="#other-semaphore-considerations" class="fancy-link wiki-link">Other semaphore
considerations</a></li>
          <li><a href="#extra-implementing-cvs-with-mutexes-alone" class="fancy-link wiki-link">Extra: Implementing CVs with Mutexes
Alone</a></li>
        </ul>
      </li>
      <li>
<a href="#barriers" class="fancy-link wiki-link">Barriers</a>
        <ul>
          <li><a href="#reader-writer-problem" class="fancy-link wiki-link">Reader Writer Problem</a></li>
          <li><a href="#attempt-1" class="fancy-link wiki-link">Attempt #1</a></li>
          <li><a href="#attempt-2" class="fancy-link wiki-link">Attempt #2:</a></li>
          <li><a href="#attempt-3" class="fancy-link wiki-link">Attempt #3</a></li>
          <li><a href="#starving-writers" class="fancy-link wiki-link">Starving writers</a></li>
          <li><a href="#attempt-4" class="fancy-link wiki-link">Attempt #4</a></li>
        </ul>
      </li>
      <li>
<a href="#ring-buffer" class="fancy-link wiki-link">Ring Buffer</a>
        <ul>
          <li><a href="#ring-buffer-gotchas" class="fancy-link wiki-link">Ring Buffer Gotchas</a></li>
          <li><a href="#multithreaded-correctness" class="fancy-link wiki-link">Multithreaded Correctness</a></li>
          <li><a href="#analysis" class="fancy-link wiki-link">Analysis</a></li>
          <li><a href="#another-analysis" class="fancy-link wiki-link">Another Analysis</a></li>
          <li><a href="#correct-implementation-of-a-ring-buffer" class="fancy-link wiki-link">Correct implementation of a ring
buffer</a></li>
        </ul>
      </li>
      <li>
<a href="#extra-process-synchronization" class="fancy-link wiki-link">Extra: Process Synchronization</a>
        <ul>
          <li><a href="#interruption" class="fancy-link wiki-link">Interruption</a></li>
          <li><a href="#solution" class="fancy-link wiki-link">Solution</a></li>
        </ul>
      </li>
      <li>
<a href="#extra-higher-order-models-of-synchronization" class="fancy-link wiki-link">Extra: Higher Order Models of
Synchronization</a>
        <ul>
          <li><a href="#sequentially-consistent" class="fancy-link wiki-link">Sequentially Consistent</a></li>
          <li><a href="#relaxed" class="fancy-link wiki-link">Relaxed</a></li>
          <li><a href="#acquirerelease" class="fancy-link wiki-link">Acquire/Release</a></li>
          <li><a href="#consume" class="fancy-link wiki-link">Consume</a></li>
        </ul>
      </li>
      <li><a href="#extra-actor-model-and-goroutines" class="fancy-link wiki-link">Extra: Actor Model and
Goroutines</a></li>
      <li><a href="#external-resources" class="fancy-link wiki-link">External Resources</a></li>
      <li><a href="#topics" class="fancy-link wiki-link">Topics</a></li>
      <li><a href="#questions" class="fancy-link wiki-link">Questions</a></li>
    </ul>
  </li>
</ul>

<p><span> </span></p>



<p><strong>When multithreading gets interesting</strong> - <strong>Bhuvy</strong></p>

<p>Synchronization coordinates various tasks so that they all finishin the
the correct state. In C, we have series of mechanisms to control what
threads are allowed to perform at a given state. Most of the time, the
threads can progress without having to communicate, but every so often
two or more threads may want to access a critical section. A critical
section is a section of code that can only be executed by one thread at
a time if the program is to function correctly. If two threads (or
processes) were to execute code inside the critical section at the same
time, it is possible that the program may no longer have the correct
behavior.</p>

<p>As we said in the previous chapter, race conditions happen when an
operation touches a piece of memory at the same time as another thread.
If the memory location is only accessible by one thread, for example the
automatic variable <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/i" class="fancy-link">i</a></code> below, then there is no possibility of a race
condition and no Critical Section associated with <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/i" class="fancy-link">i</a></code>. However, the
<code class="highlighter-rouge"><a href="https://linux.die.net/man/1/sum" class="fancy-link">sum</a></code> variable is a global variable and accessed by two threads. It is
possible that two threads may attempt to increment the variable at the
same time.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//shared</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">countgold</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//local to each thread</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">countgold</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">countgold</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">//Wait for both threads to finish:</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"ARRRRG sum is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A typical output of the above code is <code class="highlighter-rouge">ARGGGH sum is &lt;some number less
than expected&gt;</code> because there is a race condition. The code allows two
threads to read and write <code class="highlighter-rouge"><a href="https://linux.die.net/man/1/sum" class="fancy-link">sum</a></code> at the same time. For example, both
threads copy the current value of sum into CPU that runs each thread
(letâs pick 123). Both threads increment one to their own copy. Both
threads write back the value (124). If the threads had accessed the sum
at different times then the count would have been 125. A few of the
possible different orderings are below.</p>

<p>Permissible Pattern</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Thread 1</th>
      <th style="text-align: right">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Load Addr, Add 1 (i=1 locally)</td>
      <td style="text-align: right">â¦</td>
    </tr>
    <tr>
      <td style="text-align: left">Store (i=1 globally)</td>
      <td style="text-align: right">â¦</td>
    </tr>
    <tr>
      <td style="text-align: left">â¦</td>
      <td style="text-align: right">Load Addr, Add 1 (i=2 locally)</td>
    </tr>
    <tr>
      <td style="text-align: left">â¦</td>
      <td style="text-align: right">Store (i=2 globally)</td>
    </tr>
  </tbody>
</table>

<p>Good Thread Access Pattern</p>

<p>Partial Overlap</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Thread 1</th>
      <th style="text-align: right">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Load Addr, Add 1 (i=1 locally)</td>
      <td style="text-align: right">â¦</td>
    </tr>
    <tr>
      <td style="text-align: left">Store (i=1 globally)</td>
      <td style="text-align: right">Load Addr, Add 1 (i=1 locally)</td>
    </tr>
    <tr>
      <td style="text-align: left">â¦</td>
      <td style="text-align: right">Store (i=1 globally)</td>
    </tr>
  </tbody>
</table>

<p>Bad Thread Access Pattern</p>

<p>Full Overlap</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Thread 1</th>
      <th style="text-align: right">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Load Addr, Add 1 (i=1 locally)</td>
      <td style="text-align: right">Load Addr, Add 1 (i=1 locally)</td>
    </tr>
    <tr>
      <td style="text-align: left">Store (i=1 globally)</td>
      <td style="text-align: right">Store (i=1 globally)</td>
    </tr>
  </tbody>
</table>

<p>Horrible Thread Access Pattern</p>

<p>We would like the first pattern of the code being mutually exclusive.
Which leads us to our first synchronization primitive, a Mutex.</p>

<div class="pad"><div class="card">
<div class="title"><h2 id="mutex" class="title-text">Mutex<a class="anchor title-text" href="#mutex">#</a>
</h2></div>



























































































<!-- end list -->













<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>To ensure that only one thread at a time can access a global variable,
use a mutex â short for Mutual Exclusion. If one thread is currently
inside a critical section we would like another thread to wait until the
first thread is complete. A mutex isnât a primitive in the truest sense,
though it is one of the smallest that has useful threading API. A mutex
also isnât a data structure. It is an abstract data type. There are many
ways to implement a mutex, and weâll give a few in this chapter. For
right now letâs use the black box that the pthread library gives us.
Here is how we declare a mutex.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span> <span class="c1">// global variable</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">// start of Critical Section</span>
<span class="c1">// Critical section</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">//end of Critical Section</span>
</code></pre></div></div>
<h3 id="mutex-lifetime" class="title-text">Mutex Lifetime</h3>
<p>There are a few ways of initializing a mutex. A program can use the
macro <code class="highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code> only for global (âstaticâ) variables.
<code class="highlighter-rouge">m = PTHREAD_MUTEX_INITIALIZER</code> is functionally equivalent to the more
general purpose <code class="highlighter-rouge">pthread_mutex_init(&amp;m,NULL)</code>. The init version includes
options to trade performance for additional error-checking and advanced
sharing options. The init version also makes sure that the mutex is
correctly initialized after the call, global mutexes are initialized on
the first lock. A program can also call the init function inside of a
program for a mutex located on the heap.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="p">));</span>
<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="c1">//later</span>
<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>
<p>Once we are finished with the mutex we should also call
<code class="highlighter-rouge">pthread_mutex_destroy(&amp;m)</code> too. Note, a program can only destroy an
unlocked mutex, destroy on a locked mutex is undefined behavior. Things
to keep in mind about <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/init" class="fancy-link">init</a></code> and <code class="highlighter-rouge">destroy</code> A program doesnât need to
destroy a mutex created with the global initializer.</p>
<ol>
  <li>
    <p>Multiple threads init/destroy has undefined behavior</p>
  </li>
  <li>
    <p>Destroying a locked mutex has undefined behavior</p>
  </li>
  <li>
    <p>Keep to the pattern of one and only one thread initializing a mutex.</p>
  </li>
  <li>
    <p>Copying the bytes of the mutex to a new memory location and then
using the copy is <em>not</em> supported. To reference a mutex, a program
<em>must</em> to have a pointer to that memory address.</p>
  </li>
</ol>
<h3 id="mutex-usages" class="title-text">Mutex Usages</h3>
<p>How does one use a mutex? Here is a complete example in the spirit of
the earlier piece of code.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
</span>
<span class="c1">// Create a mutex this ready to be locked!</span>
<span class="n">pthread_mutex_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">countgold</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="c1">//Same thread that locks the mutex must unlock it</span>
  <span class="c1">//Critical section is 'sum += 1'</span>
  <span class="c1">//However locking and unlocking a million times</span>
  <span class="c1">//has significant overhead</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="c1">// Other threads that call lock will have to wait until we call unlock</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">countgold</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">countgold</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"ARRRRG sum is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In the code above, the thread gets the lock to the counting house before
entering. The critical section is only the <code class="highlighter-rouge">sum+=1</code> so the following
version is also correct.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>
<p>This process runs slower because we lock and unlock the mutex a million
times, which is expensive - at least compared with incrementing a
variable. In this simple example, we didnât need threads - we could have
added up twice! A faster multi-thread example would be to add one
million using an automatic (local) variable and only then adding it to a
shared total after the calculation loop has finished:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">local</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="n">sum</span> <span class="o">+=</span> <span class="n">local</span><span class="p">;</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>
<p>If you know the Gaussian sum, you can avoid race conditions altogether,
but this is for illustration.</p>
<p>Starting with the gotchas. Firstly, C Mutexes do not lock variables. A
mutex is a simple data structure. It works with code, not data. If a
mutex is locked, the other threads will continue. Itâs only when a
thread attempts to lock a mutex that is already locked, will the thread
have to wait. As soon as the original thread unlocks the mutex, the
second (waiting) thread will acquire the lock and be able to continue.
The following code creates a mutex that does effectively nothing.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">,</span>
<span class="n">m2</span> <span class="o">=</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="c1">// later</span>
<span class="c1">// Thread 1</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
<span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>

<span class="c1">// Thread 2</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>
<span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>
</code></pre></div></div>
<p>Here are some other gotchas in no particular order</p>
<ol>
  <li>
    <p>Donât cross the streams! If using threads, donât fork in the middle
of your program. This means any time after your mutexes have been
initialized.</p>
  </li>
  <li>
    <p>The thread that locks a mutex is the only thread that can unlock it.</p>
  </li>
  <li>
    <p>Each program can have multiple mutex locks. A thread safe design
might include a lock with each data structure, one lock per heap, or
one lock per set of data structures If a program has only one lock,
then there may be significant contention for the lock. If two
threads were updating two different counters, it isnât necessary to
use the same lock.</p>
  </li>
  <li>
    <p>Locks are only tools. They donât spot critical sections!</p>
  </li>
  <li>
    <p>There will always be a small amount of overhead of calling
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link">pthread_mutex_lock</a></code> and <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_unlock" class="fancy-link">pthread_mutex_unlock</a></code>. However, this is
the price to pay for correctly functioning programs!</p>
  </li>
  <li>
    <p>Not unlocking a mutex due to an early return during an error
condition</p>
  </li>
  <li>
    <p>Resource leak (not calling <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_destroy" class="fancy-link">pthread_mutex_destroy</a></code>)</p>
  </li>
  <li>
    <p>Using an uninitialized mutex or using a mutex that has already been
destroyed</p>
  </li>
  <li>
    <p>Locking a mutex twice on a thread without unlocking first</p>
  </li>
  <li>
    <p>Deadlock</p>
  </li>
</ol>
<h3 id="mutex-implementation" class="title-text">Mutex Implementation</h3>
<p>So we have this cool data structure. How do we implement it? A naive,
incorrect implementation is shown below. The <code class="highlighter-rouge">unlock</code> function simply
unlocks the mutex and returns. The lock function first checks to see if
the lock is already locked. If it is currently locked, it will keep
checking again until another thread has unlocked the mutex. For the time
being, weâll avoid the condition that other threads are able to unlock a
lock they donât own and focus on the mutual exclusion aspect.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Version 1 (Incorrect!)</span>

<span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*Locked? Never-mind - loop and check again!*/</span> <span class="p">}</span>

  <span class="n">m</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Version 1 uses âbusy-waitingâ unnecessarily wasting CPU resources.
However, there is a more serious problem. We have a race-condition! If
two threads both called <code class="highlighter-rouge"><a href="https://linux.die.net/man/2/lock" class="fancy-link">lock</a></code> concurrently, it is possible that both
threads would read <code class="highlighter-rouge">m_locked</code> as zero. Thus both threads would believe
they have exclusive access to the lock and both threads will continue.</p>
<p>We might attempt to reduce the CPU overhead a little by calling
<code class="highlighter-rouge">pthread_yield()</code> inside the loop - pthread_yield suggests to the
operating system that the thread does not use the CPU for a short while,
so the CPU may be assigned to threads that are waiting to run. This
still leaves the race-condition. We need a better implementation. We
will talk about this later in the critical section part of this chapter.
For now, we will talk about semaphores.</p>
<h3 id="extra-implementing-a-mutex-with-hardware" class="title-text">Extra: Implementing a Mutex with hardware</h3>
<p>We can use C11 Atomics to do that perfectly! A complete solution is
detailed here. This is a spinlock mutex,
<a href="https://locklessinc.com/articles/mutex_cv_futex/" class="fancy-link wiki-link">https://locklessinc.com/articles/mutex_cv_futex/</a>
implementations can be found online.</p>
<p>First the data structure and initialization code.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">mutex_</span><span class="p">{</span>
  <span class="c1">// We need some variable to see if the lock is locked</span>
  <span class="n">atomic_int_least8_t</span> <span class="n">lock</span><span class="p">;</span>
  <span class="c1">// A mutex needs to keep track of its owner so</span>
  <span class="c1">// Another thread can't unlock it</span>
  <span class="n">pthread_t</span> <span class="n">owner</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mutex</span><span class="p">;</span>

<span class="cp">#define UNLOCKED 0
#define LOCKED 1
#define UNASSIGNED_OWNER 0
</span>
<span class="kt">int</span> <span class="nf">mutex_init</span><span class="p">(</span><span class="n">mutex</span><span class="o">*</span> <span class="n">mtx</span><span class="p">){</span>
  <span class="c1">// Some simple error checking</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mtx</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Not thread-safe the user has to take care of this</span>
  <span class="n">atomic_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">UNLOCKED</span><span class="p">);</span>
  <span class="n">mtx</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">UNASSIGNED_OWNER</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is the initialization code, nothing fancy here. We set the state of
the mutex to unlocked and set the owner to locked.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">mutex_lock</span><span class="p">(</span><span class="n">mutex</span><span class="o">*</span> <span class="n">mtx</span><span class="p">){</span>
  <span class="kt">int_least8_t</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">UNLOCKED</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_compare_exchange_weak_explicit</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
  <span class="o">&amp;</span><span class="n">zero</span><span class="p">,</span>
  <span class="n">LOCKED</span><span class="p">,</span>
  <span class="n">memory_order_seq_cst</span><span class="p">,</span>
  <span class="n">memory_order_seq_cst</span><span class="p">)){</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">UNLOCKED</span><span class="p">;</span>
    <span class="n">sched_yield</span><span class="p">();</span> <span class="c1">// Use system calls for scheduling speed</span>
  <span class="p">}</span>
  <span class="c1">// We have the lock now</span>
  <span class="n">mtx</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>What does this code do? It initializes a variable that we will keep as
the unlocked state.
<a href="https://en.wikipedia.org/wiki/Compare-and-swap" class="fancy-link wiki-link">https://en.wikipedia.org/wiki/Compare-and-swap</a>
is an instruction supported by most modern architectures (on x86 itâs
<code class="highlighter-rouge">lock cmpxchg</code>). The pseudocode for this operation looks like this</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">atomic_compare_exchange_pseudo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">addr1</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">addr2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">addr1</span> <span class="o">==</span> <span class="o">*</span><span class="n">addr2</span><span class="p">){</span>
    <span class="o">*</span><span class="n">addr1</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="o">*</span><span class="n">addr2</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Except it is all done <em>atomically</em> meaning in one uninterruptible
operation. What does the <em>weak</em> part mean? Atomic instructions are prone
to <strong>spurious failures</strong> meaning that there are two versions to these
atomic functions a <em>strong</em> and a <em>weak</em> part, strong guarantees the
success or failure while weak may fail even when the operation succeeds.
These are the same spurious failures that youâll see in condition
variables below. We are using weak because weak is faster, and we are in
a loop! That means we are okay if it fails a little bit more often
because we will keep spinning around anyway.</p>
<p>Inside the while loop, we have failed to grab the lock! We reset zero
to unlocked and sleep for a little while. When we wake up we try to grab
the lock again. Once we successfully swap, we are in the critical
section! We set the mutexâs owner to the current thread for the unlock
method and return successfully.</p>
<p>How does this guarantee mutual exclusion? When working with atomics we
are unsure! But in this simple example, we can because the thread that
can successfully expect the lock to be UNLOCKED (0) and swap it to a
LOCKED (1) state is considered the winner. How do we implement unlock?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">mutex_unlock</span><span class="p">(</span><span class="n">mutex</span><span class="o">*</span> <span class="n">mtx</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">()</span> <span class="o">!=</span> <span class="n">mtx</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)){</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Can't unlock a mutex if the thread isn't the owner</span>
  <span class="p">}</span>
  <span class="kt">int_least8_t</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">//Critical section ends after this atomic</span>
  <span class="n">mtx</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">UNASSIGNED_OWNER</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_compare_exchange_strong_explicit</span><span class="p">(</span>
  <span class="o">&amp;</span><span class="n">mtx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
  <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span>
  <span class="n">UNLOCKED</span><span class="p">,</span>
  <span class="n">memory_order_seq_cst</span><span class="p">,</span>
  <span class="n">memory_order_seq_cst</span><span class="p">)){</span>
    <span class="c1">//The mutex was never locked in the first place</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To satisfy the API, a thread canât unlock the mutex unless the thread is
the one who owns it. Then we unassign the mutex owner, because critical
section is over after the atomic. We want a strong exchange because we
donât want to block. We expect the mutex to be locked, and we swap it to
unlock. If the swap was successful, we unlocked the mutex. If the swap
wasnât, that means that the mutex was UNLOCKED and we tried to switch it
from UNLOCKED to UNLOCKED, preserving the behavior of unlock.</p>
<p>What is this memory order business? We were talking about memory fences
earlier, here it is! We wonât go into detail because it is outside the
scope of this course but in the scope of
<a href="https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync" class="fancy-link wiki-link">https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync</a>.
We need consistency to make sure no loads or stores are ordered before
or after. A program need to create dependency chains for more efficient
ordering.</p>
<h3 id="semaphore" class="title-text">Semaphore</h3>
<p>A semaphore is another synchronization primitive. It is initialized to
some value. Threads can either <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_wait" class="fancy-link">sem_wait</a></code> or <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code> which lowers or
increases the value. If the value reaches zero and a wait is called, the
thread will be blocked until a post is called.</p>
<p>Using a semaphore is as easy as using a mutex. First, decide if on the
initial value, for example the number of remaining spaces in an array.
Unlike pthread mutex there are no shortcuts to creating a semaphore -
use <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_init" class="fancy-link">sem_init</a></code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;semaphore.h&gt;
</span>
<span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// returns -1 (=FAILED) on OS X</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="c1">// Could do this 10 times without blocking</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="c1">// Announce that we've finished (and one more resource item is available; increment count)</span>
  <span class="n">sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="c1">// release resources of the semaphore</span>
<span class="p">}</span>
</code></pre></div></div>
<p>When using a semaphore, wait and post can be called from different
threads! Unlike a mutex, the increment and decrement can be from
different threads.</p>
<p>This becomes especially useful if you want to use a semaphore to
implement a mutex. A mutex is a semaphore that always <code class="highlighter-rouge">waits</code> before it
<code class="highlighter-rouge">posts</code>. Some textbooks will refer to a mutex as a binary semaphore. You
do have to be careful to never add more than one to a semaphore or
otherwise your mutex abstraction breaks. That is usually why a mutex is
used to implement a semaphore and vice versa.</p>
<ul>
  <li>
    <p>Initialize the semaphore with a count of one.</p>
  </li>
  <li>
    <p>Replace <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link">pthread_mutex_lock</a></code> with <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_wait" class="fancy-link">sem_wait</a></code></p>
  </li>
  <li>
    <p>Replace <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_unlock" class="fancy-link">pthread_mutex_unlock</a></code> with <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code></p>
  </li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>
<span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Critical Section</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div>
<p>But be warned, it isnât the same! A mutex can handle what we call lock
inversion well. Meaning the following code breaks with a traditional
mutex, but produces a race condition with threads.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Thread 1</span>
<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Critical Section</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="c1">// Thread 2</span>
<span class="c1">// Some threads want to see the world burn</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="c1">// Thread 3</span>
<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Not thread-safe!</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div>
<p>If we replace it with mutex lock, it wonât work now.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Thread 1</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Critical Section</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="c1">// Thread 2</span>
<span class="c1">// Foiled!</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="c1">// Thread 3</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Now it's thread-safe</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div>
<p>Also, binary semaphores are different than mutexes because one thread
can unlock a mutex from a different thread.</p>
<div class="pad"><div class="card">
<h4 id="signal-safety">Signal Safety</h4>

<p>Also, <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code> is one of a handful of functions that can be correctly
used inside a signal handler <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_unlock" class="fancy-link">pthread_mutex_unlock</a></code> is not. We can
release a waiting thread that can now make all of the calls that we
disallowed to call inside the signal handler itself e.g. <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/printf" class="fancy-link">printf</a></code>. Here
is some code that utilizes this;</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;signal.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="cm">/* Release the Kraken! */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">singsong</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Waiting until a signal releases...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* Initial value of zero*/</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"Could not create unnamed semaphore"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span> <span class="c1">// Too simple! See Signals chapter</span>

  <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">singsong</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="cm">/* Process will exit when there are no more threads */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Other uses for semaphores are keeping track of empty spaces in arrays.
We will discuss these in the thread-safe data structures section.</p>

</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="condition-variables" class="title-text">Condition Variables<a class="anchor title-text" href="#condition-variables">#</a>
</h2></div>



































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Condition variables allow a set of threads to sleep until woken up. The
API allows either one or all threads to be woken up. If a program only
wakes one thread, the operating system will decide which thread to wake
up. Threads donât wake threads other directly like by id. Instead, a
thread âsignalâs the condition variable, which then will wake up one (or
all) threads that are sleeping inside the condition variable.</p>
<p>Condition variables are also used with a mutex and with a loop, so when
woken up they have to check a condition in a critical section. If a
thread needs to be woken up outside of a critical section, there are
other ways to do this in POSIX. Threads sleeping inside a condition
variable are woken up by calling <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_broadcast" class="fancy-link">pthread_cond_broadcast</a></code> (wake up all)
or <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code> (wake up one). Note despite the function name,
this has nothing to do with POSIX <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/signal" class="fancy-link">signal</a></code>s!</p>
<p>Occasionally, a waiting thread may appear to wake up for no reason. This
is called a <em>spurious wakeup</em>. If you read the hardware implementation
of a mutex section, this is similar to the atomic failure of the same
name.</p>
<p>Why do spurious wakeups happen? For performance. On multi-CPU systems,
it is possible that a race condition could cause a wake-up (signal)
request to be unnoticed. The kernel may not detect this lost wake-up
call but can detect when it might occur. To avoid the potentially lost
signal, the thread is woken up so that the program code can test the
condition again.</p>
<h3 id="extra-why-do-condition-variables-also-need-a-mutex" class="title-text">Extra: Why do Condition Variables also need a mutex?</h3>
<p>Condition variables need a mutex for a few reasons. One is simply that a
mutex is needed to synchronize the changes of the <em>condition variable</em>
across threads. Imagine a condition variable needing to provide its own
internal synchronization to ensure its data structures work correctly.
Often, we use a mutex to synchronize other parts of our code, so why
double the cost of using a condition variable. Another example relates
to high priority systems. Letâs examine a code snippet.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Thread 1</span>
<span class="k">while</span> <span class="p">(</span><span class="n">answer</span> <span class="o">&lt;</span> <span class="mi">42</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="n">cv</span><span class="p">);</span>

<span class="c1">// Thread 2</span>
<span class="n">answer</span> <span class="o">=</span> <span class="mi">42</span>
<span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">cv</span><span class="p">);</span>
</code></pre></div></div>
<table class="table">
  <thead>
    <tr>
      <th style="text-align: center">Thread 1</th>
      <th style="text-align: center">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">while(answer &lt; 42)</td>
      <td style="text-align: center">Â </td>
    </tr>
    <tr>
      <td style="text-align: center">Â </td>
      <td style="text-align: center">answer++</td>
    </tr>
    <tr>
      <td style="text-align: center">Â </td>
      <td style="text-align: center">pthread_cond_signal(cv)</td>
    </tr>
    <tr>
      <td style="text-align: center">pthread_cond_wait(cv)</td>
      <td style="text-align: center">Â </td>
    </tr>
  </tbody>
</table>
<p>Signaling without Mutex</p>
<p>The problem here is that a programmer expects the signal to wake up the
waiting thread. Since instructions are allowed to be interleaved without
a mutex, this causes an interleaving that is confusing to application
designers. Note that technically the API of the condition variable is
satisfied. The wait call <em>happens-after</em> the call to signal, and signal
is only required to release at most a single thread whose call to wait
<em>happened-before</em>.</p>
<p>Another problem is the need to satisfy real-time scheduling concerns
which we only outline here. In a time-critical application, the waiting
thread with the <em>highest priority</em> should be allowed to continue first.
To satisfy this requirement the mutex must also be locked before calling
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code> or <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_broadcast" class="fancy-link">pthread_cond_broadcast</a></code>. For the curious,
<a href="https://groups.google.com/forum/?hl=ky#!msg/comp.programming.threads/wEUgPq541v8/ZByyyS8acqMJ" class="fancy-link wiki-link">https://groups.google.com/forum/?hl=ky#!msg/comp.programming.threads/wEUgPq541v8/ZByyyS8acqMJ</a>.</p>
<h3 id="condition-wait-example" class="title-text">Condition Wait Example</h3>
<p>The call <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_wait" class="fancy-link">pthread_cond_wait</a></code> performs three actions:</p>
<ol>
  <li>
    <p>Unlock the mutex. The mutex must be locked.</p>
  </li>
  <li>
    <p>Sleeps until <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code> is called on the same condition
variable.</p>
  </li>
  <li>
    <p>Before returning, locks the mutex.</p>
  </li>
</ol>
<p>Condition variables are <em>always</em> used with a mutex lock. Before calling
<em>wait</em>, the mutex lock must be locked and <em>wait</em> must be wrapped with a
loop.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_cond_t</span> <span class="n">cv</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

<span class="c1">// Initialize</span>
<span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Thread 1</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="cm">/* Remember that cond_wait unlocks the mutex before blocking (waiting)! */</span>
  <span class="cm">/* After unlocking, other threads can claim the mutex. */</span>
  <span class="cm">/* When this thread is later woken it will */</span>
  <span class="cm">/* re-lock the mutex before returning */</span>
<span class="p">}</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

<span class="c1">//later clean up with pthread_cond_destroy(&amp;cv); and mutex_destroy</span>


<span class="c1">// Thread 2:</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">count</span><span class="o">++</span><span class="p">;</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
  <span class="cm">/* Even though the other thread is woken up it cannot not return */</span>
  <span class="cm">/* from pthread_cond_wait until we have unlocked the mutex. This is */</span>
  <span class="cm">/* a good thing! In fact, it is usually the best practice to call */</span>
  <span class="cm">/* cond_signal or cond_broadcast before unlocking the mutex */</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is a pretty naive example, but it shows that we can tell threads to
wake up in a standardized manner. In the next section, we will use these
to implement efficient blocking data structures.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="thread-safe-data-structures" class="title-text">Thread-Safe Data Structures<a class="anchor title-text" href="#thread-safe-data-structures">#</a>
</h2></div>











































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Naturally, we want our data structures to be thread-safe as well! We
can use mutexes and synchronization primitives to make that happen.
First a few definitions. Atomicity is when an operation is thread-safe.
We have atomic instructions in hardware by providing the lock prefix</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lock ...
</code></pre></div></div>
<p>But Atomicity also applies to higher orders of operations. We say a data
structure operation is atomic if it happens all at once and successfully
or not at all.</p>
<p>As such, we can use synchronization primitives to make our data
structures thread-safe. For the most part, we will be using mutexes
because they carry more semantic meaning than a binary semaphore. Note,
this is an introduction. Writing high-performance thread-safe data
structures requires its own book! Take for example the following
thread-unsafe stack.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A simple fixed-sized stack (version 1)</span>
<span class="cp">#define STACK_SIZE 20
</span><span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">values</span><span class="p">[</span><span class="n">STACK_SIZE</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Version 1 of the stack is thread-unsafe because if two threads call push
or pop at the same time then the results or the stack can be
inconsistent. For example, imagine if two threads call pop at the same
time then both threads may read the same value, both may read the
original count value.</p>
<p>To turn this into a thread-safe data structure we need to identify the
<em>critical sections</em> of our code, meaning we need to ask which section(s)
of the code must only have one thread at a time. In the above example
the <code class="highlighter-rouge">push</code>, <code class="highlighter-rouge">pop</code>, and <code class="highlighter-rouge">is_empty</code> functions access the same memory and
all critical sections for the stack. While <code class="highlighter-rouge">push</code> (and <code class="highlighter-rouge">pop</code>) is
executing, the data structure is an inconsistent state, for example the
count may not have been written to, so it may still contain the original
value. By wrapping these methods with a mutex we can ensure that only
one thread at a time can update (or read) the stack. A candidate
âsolutionâ is shown below. Is it correct? If not, how will it fail?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An attempt at a thread-safe stack (version 2)</span>
<span class="cp">#define STACK_SIZE 20
</span><span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">values</span><span class="p">[</span><span class="n">STACK_SIZE</span><span class="p">];</span>

<span class="n">pthread_mutex_t</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Version 2 contains at least one error. Take a moment to see if you can
the error(s) and work out the consequence(s).</p>
<p>If three threads called <code class="highlighter-rouge">push()</code> at the same time, the lock <code class="highlighter-rouge">m1</code> ensures
that only one thread at time manipulates the stack on push or is_empty
â Two threads will need to wait until the first thread completes A
similar argument applies to concurrent calls to <code class="highlighter-rouge">pop</code>. However, Version
2 does not prevent push and pop from running at the same time because
<code class="highlighter-rouge">push</code> and <code class="highlighter-rouge">pop</code> use two different mutex locks. The fix is simple in
this case - use the same mutex lock for both the push and pop functions.</p>
<p>The code has a second error. <code class="highlighter-rouge">is_empty</code> returns after the comparison and
leaves the mutex unlocked. However, the error would not be spotted
immediately. For example, suppose one thread calls <code class="highlighter-rouge">is_empty</code> and a
second thread later calls <code class="highlighter-rouge">push</code>. This thread would mysteriously stop.
Using debugger, you can discover that the thread is stuck at the lock()
method inside the <code class="highlighter-rouge">push</code> method because the lock was never unlocked by
the earlier <code class="highlighter-rouge">is_empty</code> call. Thus an oversight in one thread led to
problems much later in time in an arbitrary other thread. Letâs try to
rectify these problems</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An attempt at a thread-safe stack (version 3)</span>
<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
<span class="n">pthread_mutex_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Version 3 is thread-safe. We have ensured mutual exclusion for all of
the critical sections. There are a few things to note.</p>
<ul>
  <li>
    <p><code class="highlighter-rouge">is_empty</code> is thread-safe but its result may already be out-of-date.
The stack may no longer be empty by the time the thread gets the
result! This is usually why in thread-safe data structures,
functions that return sizes are removed or deprecated.</p>
  </li>
  <li>
    <p>There is no protection against underflow (popping on an empty stack)
or overflow (pushing onto an already-full stack)</p>
  </li>
</ul>
<p>The last point can be fixed using counting semaphores. The
implementation assumes a single stack. A more general-purpose version
might include the mutex as part of the memory structure and use
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_init" class="fancy-link">pthread_mutex_init</a></code> to initialize the mutex. For example,</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Support for multiple stacks (each one has a mutex)</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">stack</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">double</span> <span class="o">*</span><span class="n">values</span><span class="p">;</span>
<span class="p">}</span> <span class="n">stack_t</span><span class="p">;</span>

<span class="n">stack_t</span><span class="o">*</span> <span class="nf">stack_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">stack_t</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">stack_t</span><span class="p">));</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">values</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">);</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">stack_destroy</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">);</span>
  <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Warning no underflow or overflow checks!</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">stack_t</span> <span class="o">*</span><span class="n">s1</span> <span class="o">=</span> <span class="n">stack_create</span><span class="p">(</span><span class="mi">10</span> <span class="cm">/* Max capacity*/</span><span class="p">);</span>
  <span class="n">stack_t</span> <span class="o">*</span><span class="n">s2</span> <span class="o">=</span> <span class="n">stack_create</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">push</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">141</span><span class="p">);</span>
  <span class="n">push</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">pop</span><span class="p">(</span><span class="n">s1</span><span class="p">));</span>
  <span class="n">stack_destroy</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
  <span class="n">stack_destroy</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Before we fix the problems with semaphores. How would we fix the
problems with condition variables? Try it out before you look at the
code in the previous section. We need to wait in push and pop if our
stack is full or empty respectively. Attempted solution:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Assume cv is a condition variable</span>
<span class="c1">// correctly initialized</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Does the following solution work? Take a second before looking at the
answer to spot the errors.</p>
<p>So did you catch all of them?</p>
<ol>
  <li>
    <p>The first one is a simple one. In push, our check should be against
the total capacity, not zero.</p>
  </li>
  <li>
    <p>We only have if statement checks. wait() could spuriously wake up</p>
  </li>
  <li>
    <p>We never signal any of the threads! Threads could get stuck waiting
indefinitely.</p>
  </li>
</ol>
<p>Letâs fix those errors Does this solution work?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)];</span>
  <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This solution doesnât work either! The problem is with the signal. Can
you see why? What would you do to fix it?</p>
<p>Now, how would we use counting semaphores to prevent over and underflow?
Letâs discuss it in the next section.</p>
<h3 id="using-semaphores" class="title-text">Using Semaphores</h3>
<p>Letâs use a counting semaphore to keep track of how many spaces remain
and another semaphore to track the number of items in the stack. We will
call these two semaphores <code class="highlighter-rouge">sremain</code> and <code class="highlighter-rouge">sitems</code>. Remember <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_wait" class="fancy-link">sem_wait</a></code>
will wait if the semaphoreâs count has been decremented to zero (by
another thread calling sem_post).</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Sketch #1</span>

<span class="n">sem_t</span> <span class="n">sitems</span><span class="p">;</span>
<span class="n">sem_t</span> <span class="n">sremain</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">stack_init</span><span class="p">(){</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one item</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
  <span class="p">...</span>

  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Wait until there's at least one space</span>
    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
    <span class="p">...</span>
  <span class="p">}</span>
</code></pre></div></div>
<p>Sketch #2 has implemented the <code class="highlighter-rouge"><a href="https://linux.die.net/man/1/post" class="fancy-link">post</a></code> too early. Another thread waiting
in push can erroneously attempt to write into a full stack. Similarly, a
thread waiting in the pop() is allowed to continue too early.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Sketch #2 (Error!)</span>
<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one item</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span> <span class="c1">// error! wakes up pushing() thread too early</span>
  <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one space</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span> <span class="c1">// error! wakes up a popping() thread too early</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Sketch 3 implements the correct semaphore logic, but can you spot the
error?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Sketch #3 (Error!)</span>
<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one item</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span><span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one space</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Sketch 3 correctly enforces buffer full and buffer empty conditions
using semaphores. However, there is no <em>mutual exclusion</em>. Two threads
can be in the <em>critical section</em> at the same time, which would corrupt
the data structure or least lead to data loss. The fix is to wrap a
mutex around the critical
section:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Simple single stack - see the above example on how to convert this into multiple stacks.</span>
<span class="c1">// Also a robust POSIX implementation would check for EINTR and error codes of sem_wait.</span>

<span class="c1">// PTHREAD_MUTEX_INITIALIZER for statics (use pthread_mutex_init() for stack/heap memory)</span>
<span class="cp">#define SPACES 10
</span><span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">values</span><span class="p">[</span><span class="n">SPACES</span><span class="p">];</span>
<span class="n">sem_t</span> <span class="n">sitems</span><span class="p">,</span> <span class="n">sremain</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremains</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SPACES</span><span class="p">);</span> <span class="c1">// 10 spaces</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one item</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">// CRITICAL SECTION</span>
  <span class="kt">double</span> <span class="n">v</span><span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span> <span class="c1">// Hey world, there's at least one space</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one space</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">// CRITICAL SECTION</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span> <span class="c1">// Hey world, there's at least one item</span>
<span class="p">}</span>
<span class="c1">// Note a robust solution will need to check sem_wait's result for EINTR (more about this later)</span>
</code></pre></div></div>
<p>What happens when we start inverting the lock and wait orders?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">v</span><span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Rather than giving you the answer, weâll let you think about this. Is
this a permissible way to lock and unlock? Is there a series of
operations that could cause a race condition? How about deadlock? If
there is, provide it. If there isnât, provide a short justification
proof of why that wonât happen.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="software-solutions-to-the-critical-section" class="title-text">Software Solutions to the Critical Section<a class="anchor title-text" href="#software-solutions-to-the-critical-section">#</a>
</h2></div>

































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>As already discussed, there are critical parts of our code that can only
be executed by one thread at a time. We describe this requirement as
âmutual exclusionâ. Only one thread (or process) may have access to
the shared resource. In multi-threaded programs, we can wrap a critical
section with mutex lock and unlock
calls:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_lock</span><span class="p">()</span> <span class="c1">// one thread allowed at a time! (others will have to wait here)</span>
<span class="c1">// ... Do Critical Section stuff here!</span>
<span class="n">pthread_mutex_unlock</span><span class="p">()</span> <span class="c1">// let other waiting threads continue</span>
</code></pre></div></div>
<p>How would we implement these lock and unlock calls? Can we create a pure
software algorithm that assures mutual exclusion? Here is our attempt
from earlier.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">p_mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="p">;</span>
  <span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">p_mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>As we touched on earlier, this implementation <em>does not satisfy Mutual
Exclusion</em> even considering that threads can unlock other threads locks.
Letâs take a close look at this âimplementationâ from two threads
running around the same time.</p>
<p>To simplify the discussion, we consider only two threads. Note these
arguments work for threads and processes and the classic CS literature
discusses these problems in terms of two processes that need exclusive
access to a critical section or shared resource. Raising a flag
represents a thread/processâs intention to enter the critical section.</p>
<p>There are three main desirable properties that we desire in a solution
to the critical section problem.</p>
<ol>
  <li>
    <p>Mutual Exclusion. The thread/process gets exclusive access. Others
must wait until it exits the critical section.</p>
  </li>
  <li>
    <p>Bounded Wait. A thread/process cannot get superseded by another
thread infinite amounts of time.</p>
  </li>
  <li>
    <p>Progress. If no thread/process is inside the critical section, the
thread/process should be able to proceed without having to wait.</p>
  </li>
</ol>
<p>With these ideas in mind, letâs examine another candidate solution that
uses a turn-based flag only if two threads both required access at the
same time.</p>
<h3 id="naive-solutions" class="title-text">Naive Solutions</h3>
<p>Remember that the pseudo-code outlined below is part of a larger
program. The thread or process will typically need to enter the critical
section many times during the lifetime of the process. So, imagine each
example as wrapped inside a loop where for a random amount of time the
thread or process is working on something else.</p>
<p>Is there anything wrong with the candidate solution described below?</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Candidate #1
wait until your flag is lowered
raise my flag
// Do Critical Section stuff
lower my flag
</code></pre></div></div>
<p>Answer: Candidate solution #1 also suffers from a race condition
because both threads/processes could read each otherâs flag value as
lowered and continue.</p>
<p>This suggests we should raise the flag <em>before</em> checking the other
threadâs flag, which is candidate solution #2 below.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Candidate #2
raise my flag
wait until your flag is lowered
// Do Critical Section stuff
lower my flag
</code></pre></div></div>
<p>Candidate #2 satisfies mutual exclusion. It is impossible for two
threads to be inside the critical section at the same time. However,
this code suffers from deadlock! Suppose two threads wish to enter the
critical section at the same time.</p>
<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Time</th>
      <th style="text-align: center">Thread 1</th>
      <th style="text-align: center">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: center">Raise Flag</td>
      <td style="text-align: center">Â </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: center">Â </td>
      <td style="text-align: center">Raise Flag</td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: center">Wait</td>
      <td style="text-align: center">Wait</td>
    </tr>
  </tbody>
</table>
<p>Candidate Solution #2 Analysis</p>
<p>Both processes are now waiting for the other one to lower their flags.
Neither one will enter the critical section as both are now stuck
forever! This suggests we should use a turn-based variable to try to
resolve who should proceed.</p>
<h3 id="turn-based-solutions" class="title-text">Turn-based solutions</h3>
<p>The following candidate solution #3 uses a turn-based variable to
politely allow one thread and then the other to continue</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Candidate #3
wait until my turn is myid
// Do Critical Section stuff
turn = yourid
</code></pre></div></div>
<p>Candidate #3 satisfies mutual exclusion. Each thread or process gets
exclusive access to the Critical Section. However, both
threads/processes must take a strict turn-based approach to use the
critical section. They are forced into an alternating critical section
access pattern. If thread 1 wishes to read a hash table every
millisecond, but another thread writes to a hash table every second,
then the reading thread would have to wait another 999ms before being
able to read from the hash table again. This âsolutionâ is ineffective
because our threads should be able to make progress and enter the
critical section if no other thread is currently in the critical
section.</p>
<h3 id="turn-and-flag-solutions" class="title-text">Turn and Flag solutions</h3>
<p>Is the following a correct solution to CSP?</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\\ Candidate #4
raise my flag
if your flag is raised, wait until my turn
// Do Critical Section stuff
turn = yourid
lower my flag
</code></pre></div></div>
<p>Analyzing these solutions is tricky. Even peer-reviewed papers on this
specific subject contain incorrect solutions
(<span class="citeproc-not-found" data-reference-id="Hyman:1966:CPC:365153.365167"><strong>???</strong></span>)!
At first glance, it appears to satisfy Mutual Exclusion, Bounded Wait
and Progress The turn-based flag is only used in the event of a tie, so
Progress and Bounded Wait is allowed and mutual exclusion appears to be
satisfied. Perhaps you can find a counter-example?</p>
<p>Candidate #4 fails because a thread does not wait until the other
thread lowers its flag. After some thought or inspiration, the following
scenario can be created to demonstrate how Mutual Exclusion is not
satisfied.</p>
<p>Imagine the first thread runs this code twice. The turn flag now points
to the second thread. While the first thread is still inside the
Critical Section, the second thread arrives. The second thread can
immediately continue into the Critical
Section!</p>
<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Turn</th>
      <th style="text-align: left">Thread # 1</th>
      <th style="text-align: left">Thread # 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">Raise my flag</td>
      <td style="text-align: left">Â </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">If your flag is raised, wait until my turn</td>
      <td style="text-align: left">Raise my flag</td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">// Do Critical Section Stuff</td>
      <td style="text-align: left">If your flag is raised, wait until my turn (TRUE!)</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">// Do Critical Section Stuff</td>
      <td style="text-align: left">Do Critical Section Stuff - OOPS</td>
    </tr>
  </tbody>
</table>
<p>Candidate Solution #4</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="working-solutions" class="title-text">Working Solutions<a class="anchor title-text" href="#working-solutions">#</a>
</h2></div>









































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>The first solution to the problem was Dekkerâs Solution. Dekkerâs
Algorithm (1962) was the first provably correct solution. Though, it was
in an unpublished paper, so it was not discovered until later (Dekker
and Dijkstra
<a href="#ref-dekker_dijkstra_1965" class="fancy-link wiki-link">#ref-dekker_dijkstra_1965</a>) (this
is an English transcribed version released in 1965). A version of the
algorithm is below.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>raise my flag
while (your flag is raised) :
   if it is your turn to win :
     lower my flag
     wait while your turn
     raise my flag
// Do Critical Section stuff
set your turn to win
lower my flag
</code></pre></div></div>
<p>Notice how the processâs flag is always raised during the critical
section no matter if the loop is iterated zero, once or more times.
Further, the flag can be interpreted as an immediate intent to enter the
critical section. Only if the other process has also raised the flag
will one process defer, lower their intent flag and wait. Letâs check
the conditions.</p>
<ol>
  <li>
    <p>Mutual Exclusion. Letâs try to sketch a simple proof. The loop
invariant is that at the start of checking the condition, your flag
has to be raised â this is by exhaustion. Since the only way that a
thread can leave the loop is by having the condition be false, the
flag must be raised for the entirety of the critical section. Since
the loop prevents a thread from exiting while the other threadâs
flag is raised and a thread has its flag raised in the critical
section, the other thread canât enter the critical section at the
same time.</p>
  </li>
  <li>
    <p>Bounded Wait. Assuming that the critical section ends in finite
time, a thread once it has left the critical section cannot then get
the critical section back. The reason being is the turn variable is
set to the other thread, meaning that that thread now has priority.
That means a thread cannot be superseded infinitely by another
thread.</p>
  </li>
  <li>
    <p>Progress. If the other thread isnât in the critical section, it will
simply continue with a simple check. We didnât make any statement
about if threads are randomly stopped by the system scheduler. This
is an idealized scenario where threads will keep executing
instructions.</p>
  </li>
</ol>
<h3 id="petersons-solution" class="title-text">Petersonâs Solution</h3>
<p>Peterson published his novel and surprisingly simple solution in 1981
(Peterson
<a href="#ref-Peterson1981MythsAT" class="fancy-link wiki-link">#ref-Peterson1981MythsAT</a>). A
version of his algorithm is shown below that uses a shared variable
<code class="highlighter-rouge">turn</code>.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Candidate #5
raise my flag
turn = other_thread_id
while (your flag is up and turn is other_thread_id)
    loop
// Do Critical Section stuff
lower my flag
</code></pre></div></div>
<p>This solution satisfies Mutual Exclusion, Bounded Wait and Progress. If
thread #2 has set turn to 2 and is currently inside the critical
section. Thread #1 arrives, <em>sets the turn back to 1</em> and now waits
until thread 2 lowers the flag.</p>
<ol>
  <li>
    <p>Mutual Exclusion. Letâs try to sketch a simple proof again. A thread
doesnât get into the critical section until the turn variable is
yours or the other threadâs flag isnât up. If the other threadâs
flag isnât up, it isnât trying to enter the critical section. That
is the first action the thread does and the last action the thread
undoes. If the turn variable is set to this thread, that means that
the other thread has given the control to this thread. Since my flag
is raised and the turn variable is set, the other thread has to wait
in the loop until the current thread is done.</p>
  </li>
  <li>
    <p>Bounded Wait. After one thread lowers, a thread waiting in the while
loop will leave because the first condition is broken. This means
that threads cannot win all the time.</p>
  </li>
  <li>
    <p>Progress. If no other thread is contesting, other threadâs flags are
not up. That means that a thread can go past the while loop and do
critical section items.</p>
  </li>
</ol>
<h3 id="extra-implementing-software-mutex" class="title-text">Extra: Implementing Software Mutex</h3>
<p>Yes With a bit of searching, it is possible to find it in production for
specific simple mobile processors today. Petersonâs algorithm is used to
implement low-level Linux Kernel locks for the Tegra mobile processor (a
system-on-chip ARM process and GPU core by Nvidia)
<a href="https://android.googlesource.com/kernel/tegra.git/+/android-tegra-3.10/arch/arm/mach-tegra/sleep.S#58" class="fancy-link wiki-link">https://android.googlesource.com/kernel/tegra.git/+/android-tegra-3.10/arch/arm/mach-tegra/sleep.S#58</a></p>
<p>In general now, CPUs and C compilers can re-order CPU instructions or
use CPU-core-specific local cache values that are stale if another core
updates the shared variables. Thus a simple pseudo-code to C
implementation is too naive for most platforms. Warning, here be
dragons! Consider this advanced and gnarly topic but (spoiler alert) a
happy ending. Consider the following code,</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="n">flag2</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* busy loop - go around again */</span>
</code></pre></div></div>
<p>An efficient compiler would infer that <code class="highlighter-rouge">flag2</code> variable is never changed
inside the loop, so that test can be optimized to <code class="highlighter-rouge">while(true)</code> Using
<code class="highlighter-rouge">volatile</code> goes some way to prevent compiler optimizations of this kind.</p>
<p>Letâs say that we solved this by telling the compiler not to optimize.
Independent instructions can be re-ordered by an optimizing compiler or
at runtime by an out-of-order execution optimization by the CPU.</p>
<p>A related challenge is that CPU cores include a data cache to store
recently read or modified main memory values. Modified values may not be
written back to main memory or re-read from memory immediately. Thus
data changes, such as the state of a flag and turn variable in the above
example, may not be shared between two CPU codes.</p>
<p>But there is a happy ending. Modern hardware addresses these issues
using âmemory fencesâ also known as a memory barrier. This prevents
instructions from getting ordered before or after the barrier. There is
a performance loss, but it is needed for correct programs!</p>
<p>Also, there are CPU instructions to ensure that main memory and the
CPUâs cache is in a reasonable and coherent state. Higher-level
synchronization primitives, such as <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link">pthread_mutex_lock</a></code> are will call
these CPU instructions as part of their implementation. Thus, in
practice, surrounding critical sections with a mutex lock and unlock
calls is sufficient to ignore these lower-level problems.</p>
<p>For further reading, we suggest the following web post that discusses
implementing Petersonâs algorithm on an x86 process and the Linux
documentation on memory
    barriers.</p>
<ol>
  <li>
    <p><a href="http://bartoszmilewski.com/2008/11/05/who-ordered-memory-fences-on-an-x86/" class="fancy-link wiki-link">http://bartoszmilewski.com/2008/11/05/who-ordered-memory-fences-on-an-x86/</a></p>
  </li>
  <li>
    <p><a href="http://lxr.free-electrons.com/source/Documentation/memory-barriers.txt" class="fancy-link wiki-link">http://lxr.free-electrons.com/source/Documentation/memory-barriers.txt</a></p>
  </li>
</ol>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="implementing-counting-semaphore" class="title-text">Implementing Counting Semaphore<a class="anchor title-text" href="#implementing-counting-semaphore">#</a>
</h2></div>























































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Now that we have a solution to the critical section problem, We can
reasonably implement a mutex. How would we implement other
synchronization primitives? Letâs start with a semaphore. To implement a
semaphore with efficient CPU usage, we will say that we have implemented
a condition variable. Implementing an O(1) space condition variable
using only a mutex is not trivial, or at least an O(1) heap condition
variable is not trivial. We donât want to call malloc while implementing
a primitive, or we may deadlock!</p>
<ul>
  <li>
    <p>We can implement a counting semaphore using condition variables.</p>
  </li>
  <li>
    <p>Each semaphore needs a count, a condition variable and a mutex</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">sem_t</span> <span class="p">{</span>
  <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">pthread_condition_t</span> <span class="n">cv</span><span class="p">;</span>
<span class="p">}</span> <span class="n">sem_t</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>
<p>Implement <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_init" class="fancy-link">sem_init</a></code> to initialize the mutex and condition variable</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pshared</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOSYS</span> <span class="cm">/* 'Not implemented'*/</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Our implementation of <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code> needs to increment the count. We will
also wake up any threads sleeping inside the condition variable. Notice
we lock and unlock the mutex so only one thread can be inside the
critical section at a time.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
  <span class="cm">/* A woken thread must acquire the lock, so it will also have to wait until we call unlock*/</span>

  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Our implementation of <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_wait" class="fancy-link">sem_wait</a></code> may need to sleep if the semaphoreâs
count is zero. Just like <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code>, we wrap the critical section using
the lock, so only one thread can be executing our code at a time. Notice
if the thread does need to wait then the mutex will be unlocked,
allowing another thread to enter <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code> and awaken us from our
sleep!</p>
<p>Also notice that even if a thread is woken up before it returns from
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_wait" class="fancy-link">pthread_cond_wait</a></code>, it must re-acquire the lock, so it will have to
wait until sem_post finishes.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span> <span class="cm">/*unlock mutex, wait, relock mutex*/</span>
  <span class="p">}</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>That is a complete implementation of a counting semaphore Notice that we
are calling <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code> every single time. In practice, this means
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code> would unnecessary call <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code> even if there
are no waiting threads. A more efficient implementation would only call
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code> when necessary
i.e.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Did we increment from zero to one- time to signal a thread sleeping inside sem_post */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* Wake up one waiting thread!*/</span>
<span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
</code></pre></div></div>
<h3 id="other-semaphore-considerations" class="title-text">Other semaphore considerations</h3>
<ul>
  <li>
    <p>A production semaphore implementation may include a queue to ensure
fairness and priority. Meaning, we wake up the highest-priority
and/or longest sleeping thread.</p>
  </li>
  <li>
    <p>An advanced use of <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_init" class="fancy-link">sem_init</a></code> allows semaphores to be shared across
processes. Our implementation only works for threads inside the same
process. We could fix this by setting the condition variable and
mutex attributes.</p>
  </li>
</ul>
<h3 id="extra-implementing-cvs-with-mutexes-alone" class="title-text">Extra: Implementing CVs with Mutexes Alone</h3>
<p>Implementing a condition variable using only a mutex isnât trivial. Here
is a sketch of how we could do it.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">cv_node_</span> <span class="p">{</span>
  <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">dynamic</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">is_awoken</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">cv_node_</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cv_node</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">cv_node_</span> <span class="o">*</span><span class="n">head</span>
<span class="p">}</span> <span class="n">cond_t</span>

<span class="kt">void</span> <span class="nf">cond_init</span><span class="p">(</span><span class="n">cond_t</span> <span class="o">*</span><span class="n">cv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">cv</span><span class="o">-&gt;</span><span class="n">dynamic</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cond_destroy</span><span class="p">(</span><span class="n">cond_t</span> <span class="o">*</span><span class="n">cv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Nothing to see here</span>
  <span class="c1">// Though may be useful for the future to put pieces</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_from_list</span><span class="p">(</span><span class="n">cond_t</span> <span class="o">*</span><span class="n">cv</span><span class="p">,</span> <span class="n">cv_node</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Function assumes mutex is locked</span>
  <span class="c1">// Some sanity checking</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// Special case head</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Otherwise find the node previous</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">cv_node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If we've found it, patch it through</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Otherwise keep walking</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// We couldn't find the node, invalid call</span>

<span class="p">}</span>
</code></pre></div></div>
<p>This is all the boring definitional stuff. The interesting stuff is
below.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">cond_wait</span><span class="p">(</span><span class="n">cond_t</span> <span class="o">*</span><span class="n">cv</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// See note (dynamic) below</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">-&gt;</span><span class="n">dynamic</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cv</span><span class="o">-&gt;</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">m</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">-&gt;</span><span class="n">dynamic</span> <span class="o">!=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Error can't wait with a different mutex!</span>
    <span class="n">abort</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">// mutex is locked so we have the critical section right now</span>
  <span class="c1">// Create linked list node _on the stack_</span>
  <span class="n">cv_node</span> <span class="n">my_node</span><span class="p">;</span>
  <span class="n">my_node</span><span class="p">.</span><span class="n">is_awoken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">my_node</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
  <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">my_node</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

  <span class="c1">// May do some cache busting here</span>
  <span class="k">while</span><span class="p">(</span><span class="n">my_node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_yield</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
  <span class="n">remove_from_list</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_node</span><span class="p">);</span>

  <span class="c1">// The dynamic binding is over</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cv</span><span class="o">-&gt;</span><span class="n">dynamic</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cond_signal</span><span class="p">(</span><span class="n">cond_t</span> <span class="o">*</span><span class="n">cv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">cv_node</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">iter</span><span class="p">;</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Signal makes sure one thread that has not woken up</span>
    <span class="c1">// is woken up</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">is_awoken</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// DON'T remove from the linked list here</span>
      <span class="c1">// There is no mutual exclusion, so we could</span>
      <span class="c1">// have a race condition</span>
      <span class="n">iter</span><span class="o">-&gt;</span><span class="n">is_awoken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// No more threads to free! No-op</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cond_broadcast</span><span class="p">(</span><span class="n">cond_t</span> <span class="o">*</span><span class="n">cv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">cv_node</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">iter</span><span class="p">;</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Wake everyone up!</span>
    <span class="n">iter</span><span class="o">-&gt;</span><span class="n">is_awoken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>So how does this work? Instead of allocating space which could lead to
deadlock. We keep the data structures or the linked list nodes on each
threadâs stack. The linked list in the wait function is created <strong>While
the thread has the mutex lock</strong> this is important because we may have a
race condition on the insert and removal. A more robust implementation
would have a mutex per condition variable.</p>
<p>What is the note about (dynamic)? In the pthread man pages, wait creates
a runtime binding to a mutex. This means that after the first call is
called, a mutex is associated with a condition variable while there is
still a thread waiting on that condition variable. Each new thread
coming in must have the same mutex, and it must be locked. Hence, the
beginning and end of wait (everything besides the while loop) are
mutually exclusive. After the last thread leaves, meaning when head is
NULL, then the binding is lost.</p>
<p>The signal and broadcast functions merely tell either one thread or all
threads respectively that they should be woken up. <strong>It doesnât modify
the linked lists because there is no mutex to prevent corruption if two
threads call signal or broadcast</strong></p>
<p>Now an advanced point. Do you see how a broadcast could cause a spurious
wakeup in this case? Consider this series of events.</p>
<ol>
  <li>
    <p>Some number more than 2 threads start waiting</p>
  </li>
  <li>
    <p>Another thread calls broadcast.</p>
  </li>
  <li>
    <p>That thread calling broadcast is stopped before it wake any threads.</p>
  </li>
  <li>
    <p>Another thread calls wait on the condition variable and adds itself
to the queue.</p>
  </li>
  <li>
    <p>Broadcast iterates through and frees all of the threads.</p>
  </li>
</ol>
<p>There is no assurance as to <em>when</em> the broadcast was called and when
threads were added in a high-performance mutex. The ways to prevent this
behavior are to include Lamport timestamps or require that broadcast be
called with the mutex in question. That way something that
<em>happens-before</em> the broadcast call doesnât get signaled after. The same
argument is put forward for signal too.</p>
<p>Did you also notice something else? <strong>This is why we ask you to signal
or broadcast before you unlock</strong>. If you broadcast after you unlock, the
time that broadcast takes could be infinite!</p>
<ol>
  <li>
    <p>Broadcast is called on a waiting queue of threads</p>
  </li>
  <li>
    <p>First thread is freed, broadcast thread is frozen. Since the mutex
is unlocked, it locks and continues.</p>
  </li>
  <li>
    <p>It continues for such a long time that it calls broadcast again.</p>
  </li>
  <li>
    <p>With our implementation of a condition variable, this would be
terminated. If you had an implementation that appended to the tail
of the list and iterated form the head to the tail, this could go on
infinitely many times.</p>
  </li>
</ol>
<p>In high-performance systems, we want to make sure that each thread that
calls wait isnât passed by another thread that calls wait. With the
current API that we have, we canât assure that. Weâd have to ask users
to pass in a mutex or use a global mutex. Instead, we tell programmers
to always signal or broadcast before unlocking.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="barriers" class="title-text">Barriers<a class="anchor title-text" href="#barriers">#</a>
</h2></div>























































































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Suppose we wanted to perform a multi-threaded calculation that has two
stages, but we donât want to advance to the second stage until the first
stage is completed. We could use a synchronization method called a
<strong>barrier</strong>. When a thread reaches a barrier, it will wait at the
barrier until all the threads reach the barrier, and then theyâll all
proceed together.</p>
<p>Think of it like being out for a hike with some friends. You make a
mental note of how many friends you have and agree to wait for each
other at the top of each hill. Say youâre the first one to reach the top
of the first hill. Youâll wait there at the top for your friends. One by
one, theyâll arrive at the top, but nobody will continue until the last
person in your group arrives. Once they do, youâll all proceed.</p>
<p>Pthreads has a function <code class="highlighter-rouge">pthread_barrier_wait()</code> that implements this.
Youâll need to declare a <code class="highlighter-rouge">pthread_barrier_t</code> variable and initialize it
with <code class="highlighter-rouge">pthread_barrier_init()</code>. <code class="highlighter-rouge">pthread_barrier_init()</code> takes the number
of threads that will be participating in the barrier as an argument.
Here is a sample program using barriers.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;
</span>
<span class="cp">#define THREAD_COUNT 4
</span>
<span class="n">pthread_barrier_t</span> <span class="n">mybarrier</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">threadFn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">id_ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">thread_id</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">id_ptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">wait_sec</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"thread %d: Wait for %d seconds.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">,</span> <span class="n">wait_sec</span><span class="p">);</span>
  <span class="n">sleep</span><span class="p">(</span><span class="n">wait_sec</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"thread %d: I'm ready...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">);</span>

  <span class="n">pthread_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mybarrier</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"thread %d: going!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">pthread_t</span> <span class="n">ids</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">short_ids</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>

  <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
  <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mybarrier</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">THREAD_COUNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">short_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadFn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">short_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"main() is ready.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">pthread_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mybarrier</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"main() is going!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">pthread_barrier_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mybarrier</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now letâs implement our own barrier and use it to keep all the threads
in sync in a large calculation. Here is our thought process,</p>
<ol>
  <li>
    <p>Threads do first calculation (use and change values in data)</p>
  </li>
  <li>
    <p>Barrier! Wait for all threads to finish first calculation before
continuing</p>
  </li>
  <li>
    <p>Threads do second calculation (use and change values in data)</p>
  </li>
</ol>
<p>The thread function has four main parts-</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// double data[256][8192]</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">calc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Do my part of the first calculation */</span>
  <span class="cm">/* Is this the last thread to finish? If so wake up all the other threads! */</span>
  <span class="cm">/* Otherwise wait until the other threads have finished part one */</span>
  <span class="cm">/* Do my part of the second calculation */</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Our main thread will create the 16 threads, and we will divide each
calculation into 16 separate pieces. Each thread will be given a unique
value (0,1,2,..15), so it can work on its own block. Since a (void*)
type can hold small integers, we will pass the value of <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/i" class="fancy-link">i</a></code> by casting
it to a void pointer.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N (16)
</span><span class="kt">double</span> <span class="n">data</span><span class="p">[</span><span class="mi">256</span><span class="p">][</span><span class="mi">8192</span><span class="p">]</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">ids</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">calc</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note, we will never dereference this pointer value as an actual memory
location.</p>
<p>We will cast it straight back to an integer.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">calc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Thread 0 will work on rows 0..15, thread 1 on rows 16..31</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">N</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">8192</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* do calc #1 */</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>After calculation 1 completes, we need to wait for the slower threads
unless we are the last thread! So, keep track of the number of threads
that have arrived at our barrier âcheckpointâ.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Global:</span>
<span class="kt">int</span> <span class="n">remain</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>

<span class="c1">// After calc #1 code:</span>
<span class="n">remain</span><span class="o">--</span><span class="p">;</span> <span class="c1">// We finished</span>
<span class="k">if</span> <span class="p">(</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*I'm last!  -  Time for everyone to wake up! */</span> <span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">remain</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* spin spin spin*/</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>However, the code has a few flaws. One is two threads might try to
decrement <code class="highlighter-rouge">remain</code>. The other is the loop is a busy loop. We can do
better! Letâs use a condition variable and then we will use a
broadcast/signal functions to wake up the sleeping threads.</p>
<p>A reminder, a condition variable is similar to a house! Threads go
there to sleep (<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_wait" class="fancy-link">pthread_cond_wait</a></code>). A threa can choose to wake up one
thread (<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code>) or all of them
(<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_broadcast" class="fancy-link">pthread_cond_broadcast</a></code>). If there are no threads currently waiting
then these two calls have no effect.</p>
<p>A condition variable version is usually similar to a busy loop incorrect
solution - as we will show next. First, letâs add a mutex and condition
global variables and donât forget to initialize them in <code class="highlighter-rouge">main</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//global variables</span>
<span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">cv</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>
<p>We will use the mutex to ensure that only one thread modifies <code class="highlighter-rouge">remain</code>
at a time. The last arriving thread needs to wake up <em>all</em> sleeping
threads - so we will use <code class="highlighter-rouge">pthread_cond_broadcast(&amp;cv)</code> not
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="n">remain</span><span class="o">--</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">remain</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</code></pre></div></div>
<p>When a thread enters <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_wait" class="fancy-link">pthread_cond_wait</a></code>, it releases the mutex and
sleeps. After, the thread will be woken up. Once we bring a thread back
from its sleep, before returning it must wait until it can lock the
mutex. Notice that even if a sleeping thread wakes up early, it will
check the while loop condition and re-enter wait if necessary.</p>
<p><strong>The above barrier is not reusable</strong>. Meaning that if we stick it into
any old calculation loop there is a good chance that the code will
encounter a condition where the barrier either deadlocks or thread races
ahead one iteration faster. Why is that? Because of the ambitious
thread.</p>
<p>We will assume that one thread is much faster than all the other
threads. With the barrier API, this thread should be waiting, but it may
not be. To make it concrete, letâs look at this code</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">barrier_wait</span><span class="p">(</span><span class="n">barrier</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="c1">// If it is 0 before decrement, we should be on</span>
  <span class="c1">// another iteration right?</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span> <span class="o">=</span> <span class="n">NUM_THREADS</span><span class="p">;</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span><span class="o">--</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Some calc</span>
  <span class="n">barrier_wait</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>What happens if a thread becomes ambitious. Well</p>
<ol>
  <li>
    <p>Many other threads wait on the condition variable</p>
  </li>
  <li>
    <p>The last thread broadcasts.</p>
  </li>
  <li>
    <p>A single thread leaves the while loop.</p>
  </li>
  <li>
    <p>This single thread performs its calculation before any other threads
<em>even wake up</em></p>
  </li>
  <li>
    <p>Reset the number of remaining threads and goes back to sleep.</p>
  </li>
</ol>
<p>All the other threads who shouldâve woken up never do and our
implementation deadlocks. How would you go about solving this? Hint: If
multiple threads call <code class="highlighter-rouge">barrier_wait</code> in a loop then one can guarantee
that they are on the same iteration.</p>
<h3 id="reader-writer-problem" class="title-text">Reader Writer Problem</h3>
<p>Imagine you had a key-value map data structure that is used by many
threads. Multiple threads should be able to look up (read) values at the
same time provided the data structure is not being written to. The
writers are not so gregarious. To avoid data corruption, only one thread
at a time may modify (<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code>) the data structure and no readers may be
reading at that time.</p>
<p>This is an example of the <em>Reader Writer Problem</em>. Namely, how can we
efficiently synchronize multiple readers and writers such that multiple
readers can read together, but a writer gets exclusive access?</p>
<p>An incorrect attempt is shown below (âlockâ is a shorthand for
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link">pthread_mutex_lock</a></code>):</p>
<h3 id="attempt-1" class="title-text">Attempt #1</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="c1">// do read stuff</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="c1">// do write stuff</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>At least our first attempt does not suffer from data corruption. Readers
must wait while a writer is writing and vice versa! However, readers
must also wait for other readers. Letâs try another implementation.</p>
<h3 id="attempt-2" class="title-text">Attempt #2:</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">writing</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*spin*/</span><span class="p">}</span>
  <span class="n">reading</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="c1">// do read stuff</span>
  <span class="n">reading</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*spin*/</span><span class="p">}</span>
  <span class="n">writing</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="c1">// do write stuff</span>
  <span class="n">writing</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Our second attempt suffers from a race condition. Imagine if two threads
both called <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/read" class="fancy-link">read</a></code> and <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code> or both called write at the same time.
Both threads would be able to proceed! Secondly, we can have multiple
readers and multiple writers, so letâs keep track of the total number of
readers or writers Which brings us to attempt #3.</p>
<h3 id="attempt-3" class="title-text">Attempt #3</h3>
<p>Remember that <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_wait" class="fancy-link">pthread_cond_wait</a></code> performs <em>Three</em> actions. Firstly, it
atomically unlocks the mutex and then sleeps (until it is woken by
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code> or <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_broadcast" class="fancy-link">pthread_cond_broadcast</a></code>). Thirdly, the awoken
thread must re-acquire the mutex lock before returning. Thus only one
thread can actually be running inside the critical section defined by
the lock and unlock() methods.</p>
<p>Implementation #3 below ensures that a reader will enter the
<code class="highlighter-rouge">cond_wait</code> if any writers are writing.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">++</span><span class="p">;</span>

  <span class="cm">/* Read here! */</span>

  <span class="n">reading</span><span class="o">--</span>
  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>However, only one reader a time can read because candidate #3 did not
unlock the mutex. A better version unlocks before reading.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">++</span><span class="p">;</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>

  <span class="cm">/* Read here! */</span>

  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">--</span>
  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Does this mean that a writer and read could read and write at the same
time? No! First of all, remember cond_wait requires the thread
re-acquire the mutex lock before returning. Thus only one thread can be
executing code inside the critical section (marked with **) at a
time!</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="o">**</span>  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
  <span class="o">**</span>      <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="o">**</span>  <span class="n">reading</span><span class="o">++</span><span class="p">;</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="cm">/* Read here! */</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="o">**</span>  <span class="n">reading</span><span class="o">--</span>
  <span class="o">**</span>  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Writers must wait for everyone. Mutual exclusion is assured by the lock.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="o">**</span>  <span class="k">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>
  <span class="o">**</span>      <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="o">**</span>  <span class="n">writing</span><span class="o">++</span><span class="p">;</span>
  <span class="o">**</span>
  <span class="o">**</span> <span class="cm">/* Write here! */</span>
  <span class="o">**</span>  <span class="n">writing</span><span class="o">--</span><span class="p">;</span>
  <span class="o">**</span>  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Candidate #3 above also uses <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cond_signal" class="fancy-link">pthread_cond_signal</a></code>. This will only wake
up one thread. If many readers are waiting for the writer to complete,
only one sleeping reader will be awoken from their slumber. The reader
and writer should use <code class="highlighter-rouge">cond_broadcast</code> so that all threads should wake
up and check their while-loop condition.</p>
<h3 id="starving-writers" class="title-text">Starving writers</h3>
<p>Candidate #3 above suffers from starvation. If readers are constantly
arriving then a writer will never be able to proceed (the âreadingâ
count never reduces to zero). This is known as <em>starvation</em> and would be
discovered under heavy loads. Our fix is to implement a bounded-wait for
the writer. If a writer arrives they will still need to wait for
existing readers however future readers must be placed in a âholding
penâ and wait for the writer to finish. The âholding penâ can be
implemented using a variable and a condition variable so that we can
wake up the threads once the writer has finished.</p>
<p>The plan is that when a writer arrives, and before waiting for current
readers to finish, register our intent to write by incrementing a
counter âwriterâ</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">()</span>
  <span class="n">writer</span><span class="o">++</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span>
  <span class="n">unlock</span><span class="p">()</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>And incoming readers will not be allowed to continue while writer is
nonzero. Notice âwriterâ indicates a writer has arrived, while âreadingâ
and âwritingâ counters indicate there is an <em>active</em> reader or writer.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">()</span>
  <span class="c1">// readers that arrive *after* the writer arrived will have to wait here!</span>
  <span class="k">while</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>

  <span class="c1">// readers that arrive while there is an active writer</span>
  <span class="c1">// will also wait.</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">++</span>
  <span class="n">unlock</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="attempt-4" class="title-text">Attempt #4</h3>
<p>Below is our first working solution to the Reader-Writer problem. Note
if you continue to read about the âReader Writer problemâ then you will
discover that we solved the âSecond Reader Writer problemâ by giving
writers preferential access to the lock. This solution is not optimal.
However, it satisfies our original problem of N active readers, single
active writer, and avoiding starvation of the writer if there is a
constant stream of readers.</p>
<p>Can you identify any improvements? For example, how would you improve
the code so that we only woke up readers or one
writer?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">writers</span><span class="p">;</span> <span class="c1">// Number writer threads that want to enter the critical section (some or all of these may be blocked)</span>
<span class="kt">int</span> <span class="n">writing</span><span class="p">;</span> <span class="c1">// Number of threads that are actually writing inside the C.S. (can only be zero or one)</span>
<span class="kt">int</span> <span class="n">reading</span><span class="p">;</span> <span class="c1">// Number of threads that are actually reading inside the C.S.</span>
<span class="c1">// if writing !=0 then reading must be zero (and vice versa)</span>

<span class="n">reader</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">writers</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="c1">// No need to wait while(writing here) because we can only exit the above loop</span>
  <span class="c1">// when writing is zero</span>
  <span class="n">reading</span><span class="o">++</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>

  <span class="c1">// perform reading here</span>

  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">--</span>
  <span class="n">cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">writer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">writers</span><span class="o">++</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">writing</span><span class="o">++</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="c1">// perform writing here</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">writing</span><span class="o">--</span>
  <span class="n">writers</span><span class="o">--</span>
  <span class="n">cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="ring-buffer" class="title-text">Ring Buffer<a class="anchor title-text" href="#ring-buffer">#</a>
</h2></div>























































<!-- end list -->











<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>A ring buffer is a simple, usually fixed-sized, storage mechanism where
contiguous memory is treated as if it is circular, and two index
counters keep track of the current beginning and end of the queue. As
array indexing is not circular, the index counters must wrap around to
zero when moved past the end of the array. As data is added (enqueued)
to the front of the queue or removed (dequeued) from the tail of the
queue, the current items in the buffer form a train that appears to
circle the track</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/synchronization/drawings/ring_buffer.png" alt="Ring Buffer
Visualization"></p>
<p>A simple (single-threaded) implementation is shown below. Note, enqueue
and dequeue do not guard against underflow or overflow. Itâs possible to
add an item when the queue is full and possible to remove an item when
the queue is empty. If we added 20 integers (1, 2, 3, â¦, 20) to the
queue and did not dequeue any items then values, <code class="highlighter-rouge">17,18,19,20</code> would
overwrite the <code class="highlighter-rouge">1,2,3,4</code>. We wonât fix this problem right now, instead of
when we create the multi-threaded version we will ensure enqueue-ing and
dequeue-ing threads are blocked while the ring buffer is full or empty
respectively.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Add one item to the front of the queue*/</span>
  <span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">in</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Advance the index for next time */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Wrap around! */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Remove one item to the end of the queue.*/</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">];</span>
  <span class="n">out</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="ring-buffer-gotchas" class="title-text">Ring Buffer Gotchas</h3>
<p>Itâs tempting to write the enqueue or dequeue method in the following
compact form.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// N is the capacity of the buffer</span>
<span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>
<p>This method would appear to work but contains a subtle bug. With more
than four billion enqueue operations, the int value of <code class="highlighter-rouge">in</code> will
overflow and wrap around to 0! Thus, you might end up writing into
<code class="highlighter-rouge">b[0]</code> for example!</p>
<p>A compact form is correct uses bit masking provided N is a power of two.
(16,32,64,â¦)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</code></pre></div></div>
<p>This buffer does not yet prevent overwrites. For that, weâll turn to our
multi-threaded attempt that will block a thread until there is space or
there is at least one item to remove.</p>
<h3 id="multithreaded-correctness" class="title-text">Multithreaded Correctness</h3>
<p>The following code is an incorrect implementation. What will happen?
Will <code class="highlighter-rouge">enqueue</code> and/or <code class="highlighter-rouge">dequeue</code> block? Is mutual exclusion satisfied?
Can the buffer underflow? Can the buffer overflow? For clarity,
<code class="highlighter-rouge">pthread_mutex</code> is shortened to <code class="highlighter-rouge">p_m</code> and we assume sem_wait cannot be
interrupted.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N 16
</span><span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">p_m_t</span> <span class="n">lock</span>
<span class="n">sem_t</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">p_m_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>

  <span class="c1">// Hint: Wait while zero. Decrement and return</span>
  <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">s1</span> <span class="p">)</span>

  <span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

  <span class="c1">// Hint: Increment. Will wake up a waiting thread</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">)</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">dequeue</span><span class="p">(){</span>
  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="p">[(</span><span class="n">out</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="analysis" class="title-text">Analysis</h3>
<p>Before reading on, see how many mistakes you can find. Then determine
what would happen if threads called the enqueue and dequeue methods.</p>
<ul>
  <li>
    <p>The enqueue method waits and posts on the same semaphore (s1) and
similarly with enqueue and (s2) i.e.Â we decrement the value and then
immediately increment the value, so by the end of the function the
semaphore value is unchanged!</p>
  </li>
  <li>The initial value of s1 is 16, so the semaphore will never be
reduced to zero - enqueue will not block if the ring buffer is full
    <ul>
      <li>so overflow is possible.</li>
    </ul>
  </li>
  <li>
    <p>The initial value of s2 is zero, so calls to dequeue will always
block and never return!</p>
  </li>
  <li>The order of mutex lock and sem_wait will need to be swapped;
however, this example is so broken that this bug has no effect!</li>
</ul>
<h3 id="another-analysis" class="title-text">Another Analysis</h3>
<p>The following code is an incorrect implementation. What will happen?
Will <code class="highlighter-rouge">enqueue</code> and/or <code class="highlighter-rouge">dequeue</code> block? Is mutual exclusion satisfied?
Can the buffer underflow? Can the buffer overflow? For clarity
<code class="highlighter-rouge">pthread_mutex</code> is shortened to <code class="highlighter-rouge">p_m</code> and we assume sem_wait cannot be
interrupted.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">p_m_t</span> <span class="n">lock</span>
<span class="n">sem_t</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">){</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>

  <span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">dequeue</span><span class="p">(){</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">)</span>
  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="p">[(</span><span class="n">out</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Here are a few problems that we hope youâve found.</p>
<ul>
  <li>
    <p>The initial value of s2 is 0. Thus enqueue will block on the first
call to sem_wait even though the buffer is empty!</p>
  </li>
  <li>
    <p>The initial value of s1 is 16. Thus dequeue will not block on the
first call to sem_wait even though the buffer is empty -
Underflow! The dequeue method will return invalid data.</p>
  </li>
  <li>
    <p>The code does not satisfy Mutual Exclusion. Two threads can modify
<code class="highlighter-rouge">in</code> or <code class="highlighter-rouge">out</code> at the same time! The code appears to use mutex lock.
Unfortunately, the lock was never initialized with
<code class="highlighter-rouge">pthread_mutex_init()</code> or <code class="highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code> - so the lock
may not work (<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link">pthread_mutex_lock</a></code> may simply do nothing)</p>
  </li>
</ul>
<h3 id="correct-implementation-of-a-ring-buffer" class="title-text">Correct implementation of a ring buffer</h3>
<p>As the mutex lock is stored in global (static) memory it can be
initialized with <code class="highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code>. If we had allocated space
for the mutex on the heap, then we would have used
<code class="highlighter-rouge">pthread_mutex_init(ptr, NULL)</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
</span><span class="c1">// N must be 2^i</span>
<span class="cp">#define N (16)
</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">p_m_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span>
<span class="n">sem_t</span> <span class="n">countsem</span><span class="p">,</span> <span class="n">spacesem</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">countsem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spacesem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The enqueue method is shown below. Make sure to note.</p>
<ol>
  <li>
    <p>The lock is only held during the critical section (access to the
data structure).</p>
  </li>
  <li>
    <p>A complete implementation would need to guard against early returns
from <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_wait" class="fancy-link">sem_wait</a></code> due to POSIX signals.</p>
  </li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">){</span>
  <span class="c1">// wait if there is no space left:</span>
  <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">spacesem</span> <span class="p">)</span>

  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>

  <span class="c1">// increment the count of the number of items</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">countsem</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="highlighter-rouge">dequeue</code> implementation is shown below. Notice the symmetry of the
synchronization calls to <code class="highlighter-rouge">enqueue</code>. In both cases, the functions first
wait if the count of spaces or count of items is zero.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">dequeue</span><span class="p">(){</span>
  <span class="c1">// Wait if there are no items in the buffer</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">countsem</span><span class="p">)</span>

  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="p">[(</span><span class="n">out</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>

  <span class="c1">// Increment the count of the number of spaces</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spacesem</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Food for thought:</p>
<ul>
  <li>
    <p>What would happen if the order of <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_unlock" class="fancy-link">pthread_mutex_unlock</a></code> and
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_post" class="fancy-link">sem_post</a></code> calls were swapped?</p>
  </li>
  <li>
    <p>What would happen if the order of <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sem_wait" class="fancy-link">sem_wait</a></code> and
<code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link">pthread_mutex_lock</a></code> calls were swapped?</p>
  </li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="extra-process-synchronization" class="title-text">Extra: Process Synchronization<a class="anchor title-text" href="#extra-process-synchronization">#</a>
</h2></div>





























<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>You thought that you were using different processes, so you donât have
to synchronize? Think again! You may not have race conditions within a
process but what if your process needs to interact with the system
around it? Letâs consider a motivating example</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">write_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"my_file.txt"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
  <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
  <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">write_string</span><span class="p">(</span><span class="s">"key1: value1"</span><span class="p">);</span>
    <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">write_string</span><span class="p">(</span><span class="s">"key2: value2"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>If none of the system calls fail then we should get something that looks
like this given the file was empty to begin with.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key1: value1
key2: value2

key2: value2
key1: value1
</code></pre></div></div>
<h3 id="interruption" class="title-text">Interruption</h3>
<p>But, there is a hidden nuance. Most system calls can be <code class="highlighter-rouge">interrupted</code>
meaning that the operating system can stop an ongoing system call
because it needs to stop the process. So barring <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fork" class="fancy-link">fork</a></code> <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/wait" class="fancy-link">wait</a></code> <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/open" class="fancy-link">open</a></code>
and <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/close" class="fancy-link">close</a></code> from failing â they typically go to completion â what
happens if <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code> fails? If write fails and no bytes are written, we
can get something like <code class="highlighter-rouge">key1: value1</code> or <code class="highlighter-rouge">key2: value2</code>. This is data
loss which is incorrect but wonât corrupt the file. What happens if
write gets interrupted after a partial write? We get all sorts of
madness. For example,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key2: key1: value1
</code></pre></div></div>
<h3 id="solution" class="title-text">Solution</h3>
<p>A program can create a mutex before fork-ing - however the child and
parent process will not share virtual memory and each one will have a
mutex independent of the other. Advanced note: There are advanced
options using shared memory that allow a child and parent to share a
mutex if itâs created with the correct options and uses a shared memory
segment. See
<a href="http://stackoverflow.com/questions/19172541/procs-fork-and-mutexes" class="fancy-link wiki-link">http://stackoverflow.com/questions/19172541/procs-fork-and-mutexes</a></p>
<p>So what should we do? We should use a shared mutex! Consider the
following code.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="o">*</span> <span class="n">mutex</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">pthread_mutexattr_t</span> <span class="n">attr</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">write_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"my_file.txt"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">bytes_to_write</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">written</span> <span class="o">&lt;</span> <span class="n">bytes_to_write</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">written</span> <span class="o">+=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">written</span><span class="p">,</span> <span class="n">bytes_to_write</span> <span class="o">-</span> <span class="n">written</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">pthread_mutexattr_setpshared</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_PROCESS_SHARED</span><span class="p">);</span>
  <span class="n">pmutex</span> <span class="o">=</span> <span class="n">mmap</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="p">),</span>
  <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="o">|</span><span class="n">MAP_ANON</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="n">pmutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attrmutex</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">write_string</span><span class="p">(</span><span class="s">"key1: value1"</span><span class="p">);</span>
    <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pmutex</span><span class="p">);</span>
    <span class="n">pthread_mutexattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attrmutex</span><span class="p">);</span>
    <span class="n">munmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pmutex</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pmutex</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">write_string</span><span class="p">(</span><span class="s">"key2: value2"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>What the code does in main is initialize a process shared mutex using a
piece of <code class="highlighter-rouge">shared</code> memory. You will find out what this call to <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code>
does later â assume for the time being that it creates memory that is
shared between processes. We can initialize a <code class="highlighter-rouge">pthread_mutex_t</code> in that
special piece of memory and use it as normal. To counter <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code>
failing, we have put the <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code> call inside a while loop that keeps
writing so long as there are bytes left to write. Now if all the other
system calls function, there should be more race conditions.</p>
<p>Most programs try to avoid this problem entirely by writing to separate
files, but it is good to know that there are mutexes across processes,
and they are useful. A program can use all of the primitives that were
mentioned previouslty! Barriers, semaphores, and condition variables
can all be initialized on a shared piece of memory and used in similar
ways to their multithreading counterparts.</p>
<ul>
  <li>
    <p>You donât have to worry about arbitrary memory addresses becoming
race condition candidates. Only areas that specifically mapped are
in danger.</p>
  </li>
  <li>
    <p>You get the nice isolation of processes so if one process fails the
system can maintain intact.</p>
  </li>
  <li>
    <p>When you have a lot of threads, creating a process might ease the
system load</p>
  </li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="extra-higher-order-models-of-synchronization" class="title-text">Extra: Higher Order Models of Synchronization<a class="anchor title-text" href="#extra-higher-order-models-of-synchronization">#</a>
</h2></div>



























<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>When using atomics, you need to specify the right model of
synchronization to ensure a program behaves correctly. You can read more
about them
<a href="https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync" class="fancy-link wiki-link">https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync</a>
These examples are adapted from those.</p>
<h3 id="sequentially-consistent" class="title-text">Sequentially Consistent</h3>
<p>Sequentially consistent is the simplest, least error-prone and most
expensive model. This model says that any change that happens, all
changes before it will be synchronized between all threads.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Thread 1                    Thread 2
    1.0 atomic_store(x, 1)
    1.1 y = 10                  2.1 if (atomic_load(x) == 0)
    1.2 atomic_store(x, 0);     2.2    y != 10 &amp;&amp; abort();
</code></pre></div></div>
<p>Will never quit. This is because either the store happens before the if
statement in thread 2 and y == 1 or the store happens after and x does
not equal 2.</p>
<h3 id="relaxed" class="title-text">Relaxed</h3>
<p>Relaxed is a simple memory order providing for more optimizations. This
means that only a particular operation needs to be atomic. One can have
stale reads and writes, but after reading the new value, it wonât become
old.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -Thread 1-              -Thread 2-
    atomic_store(x, 1);     printf("%d\n", x) // 1
    atomic_store(x, 0);     printf("%d\n", x) // could be 1 or 0
                            printf("%d\n", x) // could be 1 or 0
</code></pre></div></div>
<p>But that means that previous loads and stores donât need to affect other
threads. In the previous example, the code can now fail.</p>
<h3 id="acquirerelease" class="title-text">Acquire/Release</h3>
<p>The order of atomic variables donât need to be consistent â meaning if
atomic var y is assigned to 10 then atomic var x to be 0 those donât
need to propagate, and a threa could get stale reads. Non-atomic
variables have to get updated in all threads though.</p>
<h3 id="consume" class="title-text">Consume</h3>
<p>Imagine the same as above except non-atomic variables donât need to get
updated in all threads. This model was introduced so that there can be
an Acquire/Release/Consume model without mixing in Relaxed because
Consume is similar to relax.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="extra-actor-model-and-goroutines" class="title-text">Extra: Actor Model and Goroutines<a class="anchor title-text" href="#extra-actor-model-and-goroutines">#</a>
</h2></div>



















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>There are a <em>lot</em> of other methods of concurrency than described in this
book. Posix threads are the finest grained thread construct, allowing
for tight control of the threads and the CPU. Other languages have their
abstractions. Weâll talk about a language go that is similar to C in
terms of simplicity and design, go or golang To get the 5 minute
introduction, feel free to read
<a href="https://learnxinyminutes.com/docs/go/" class="fancy-link wiki-link">https://learnxinyminutes.com/docs/go/</a>
for go. Here is how we create a âthreadâ in go.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func hello(out) {
    fmt.Println(out);
}

func main() {
    to_print := "Hello World!"
    go hello(to_print)
}
</code></pre></div></div>
<p>This actually creates what is known as a goroutine. A goroutine can be
thought of as a lightweight thread. Internally, it is a worker pool of
threads that executes instructions of all the running goroutines. When a
goroutine needs to be stopped, it is frozen and âcontext switchedâ to
another thread. Context switch is in quotes because this is done at the
run time level versus real context switching which is done at the
operating system level.</p>
<p>The advantage to gofuncs is pretty self explanatory. There is no
boilerplate code, or joining, or odd casting <code class="highlighter-rouge">void *</code>.</p>
<p>We can still use mutexes in go to perform our end result. Consider the
counting example as before.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var counter = 0;
var mut sync.Mutex;
var wg sync.WaitGroup;
 
func plus() {
  mut.Lock()
  counter += 1
  mut.Unlock()
  wg.Done()
}

func main() {
  num := 10
  wg.Add(num);
  for i := 0; i &lt; num; i++ {
    go plus()
  }

  wg.Wait()

  fmt.Printf("%d\n", counter);

}
</code></pre></div></div>
<p>But thatâs boring and error prone. Instead, letâs use the actor model.
Letâs designate two actors. One is the main actor that will be
performing the main instruction set. The other actor will be the
counter. The counter is responsible for adding numbers to an internal
variable. Weâll send messages between the threads when we want to add
and see the value.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const (
  addRequest = iota;
  outputRequest = iota;
)

func counterActor(requestChannel chan int, outputChannel chan int) {
  counter := 0

  for {
    req := &lt;- requestChannel;
    if req == addRequest {
      counter += 1
    } else if req == outputRequest {
      outputChannel &lt;- counter
    }
  }
}

func main() {
  // Set up the actor
  requestChannel := make(chan int)
  outputChannel := make(chan int)
  go counterActor(requestChannel, outputChannel)

  num := 10
  for i := 0; i &lt; num; i++ {
    requestChannel &lt;- addRequest
  }
  requestChannel &lt;- outputRequest
  new_count := &lt;- outputChannel
  fmt.Printf("%d\n", new_count);
}
</code></pre></div></div>
<p>Although there is a bit more boilerplate code, we donât have mutexes
anymore! If we wanted to scale this operation and do other things like
increment by a number, or write to a file, we can have that particular
actor take care of it. This differentiation of responsibilities is
important to make sure your design scales well. There are even libraries
that handle all of the boilerplate code as well.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="external-resources" class="title-text">External Resources<a class="anchor title-text" href="#external-resources">#</a>
</h2></div>





<!-- end list -->



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Guiding questions for the man pages</p>
<ul>
  <li>
    <p>How is a recursive mutex different than a default mutex?</p>
  </li>
  <li>
    <p>How is mutex trylock different than mutex lock?</p>
  </li>
  <li>
    <p>Why would a mutex lock fail? Whatâs an example?</p>
  </li>
  <li>
    <p>What happens if a thread tries to destroy a locked mutex?</p>
  </li>
  <li>
    <p>Can a thread copy the underlying bytes of a mutex instead of using a
pointer?</p>
  </li>
  <li>
    <p>What is the lifecycle of a
semaphore?</p>
  </li>
</ul>
<ul>
  <li>
    <p><a href="http://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link wiki-link">http://linux.die.net/man/3/pthread_mutex_lock</a></p>
  </li>
  <li>
    <p><a href="http://linux.die.net/man/3/pthread_mutex_init" class="fancy-link wiki-link">http://linux.die.net/man/3/pthread_mutex_init</a></p>
  </li>
  <li>
    <p><a href="http://man7.org/linux/man-pages/man3/sem_init.3.html" class="fancy-link wiki-link">http://man7.org/linux/man-pages/man3/sem_init.3.html</a></p>
  </li>
  <li>
    <p><a href="http://man7.org/linux/man-pages/man3/sem_wait.3.html" class="fancy-link wiki-link">http://man7.org/linux/man-pages/man3/sem_wait.3.html</a></p>
  </li>
  <li>
    <p><a href="http://man7.org/linux/man-pages/man3/sem_post.3.html" class="fancy-link wiki-link">http://man7.org/linux/man-pages/man3/sem_post.3.html</a></p>
  </li>
  <li>
    <p><a href="http://man7.org/linux/man-pages/man3/sem_destroy.3.html" class="fancy-link wiki-link">http://man7.org/linux/man-pages/man3/sem_destroy.3.html</a></p>
  </li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="topics" class="title-text">Topics<a class="anchor title-text" href="#topics">#</a>
</h2></div>



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><ul>
  <li>
    <p>Atomic operations</p>
  </li>
  <li>
    <p>Critical Section</p>
  </li>
  <li>
    <p>Producer Consumer Problem</p>
  </li>
  <li>
    <p>Using Condition Variables</p>
  </li>
  <li>
    <p>Using Counting Semaphore</p>
  </li>
  <li>
    <p>Implementing a barrier</p>
  </li>
  <li>
    <p>Implementing a ring buffer</p>
  </li>
  <li>
    <p>Using pthread_mutex</p>
  </li>
  <li>
    <p>Implementing producer consumer</p>
  </li>
  <li>
    <p>Analyzing multi-threaded coded</p>
  </li>
</ul></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="questions" class="title-text">Questions<a class="anchor title-text" href="#questions">#</a>
</h2></div>




<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<ul>
  <li>
    <p>What is atomic operation?</p>
  </li>
  <li>
    <p>Why will the following not work in parallel code</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">//In the global section</span>
<span class="kt">size_t</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//In pthread function</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>And this will?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">//In the global section</span>
<span class="n">atomic_size_t</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//In pthread function</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">atomic_fetch_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>What are some downsides to atomic operations? What would be faster:
keeping a local variable or many atomic operations?</p>
  </li>
  <li>
    <p>What is the critical section?</p>
  </li>
  <li>
    <p>Once you have identified a critical section, what is one way of
assuring that only one thread will be in the section at a time?</p>
  </li>
  <li>
    <p>Identify the critical section here</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">linked_list</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">node</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">add_linked_list</span><span class="p">(</span><span class="n">linked_list</span> <span class="o">*</span><span class="n">ll</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">elem</span><span class="p">){</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">packaged</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">){</span>
    <span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="n">packaged</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">packaged</span><span class="p">;</span>
    <span class="n">ll</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kt">void</span><span class="o">*</span> <span class="nf">pop_elem</span><span class="p">(</span><span class="n">linked_list</span> <span class="o">*</span><span class="n">ll</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ll</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    
  <span class="n">node</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">index</span><span class="o">--</span><span class="p">){</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="c1">//i points to the element we need to pop, prev before</span>
  <span class="k">if</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">ll</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">;</span>
  <span class="n">destroy_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">elem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>How tight can you make the critical section?</p>
  </li>
  <li>
    <p>What is a producer consumer problem? How might the above be a
producer consumer problem be used in the above section? How is a
producer consumer problem related to a reader writer problem?</p>
  </li>
  <li>
    <p>What is a condition variable? Why is there an advantage to using one
over a <code class="highlighter-rouge"><a href="https://linux.die.net/man/1/while" class="fancy-link">while</a></code> loop?</p>
  </li>
  <li>
    <p>Why is this code dangerous?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">not_ready</span><span class="p">){</span>
  <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>What is a counting semaphore? Give me an analogy to a cookie
jar/pizza box/limited food item.</p>
  </li>
  <li>
    <p>What is a thread barrier?</p>
  </li>
  <li>
    <p>Use a counting semaphore to implement a barrier.</p>
  </li>
  <li>
    <p>Write up a Producer/Consumer queue, How about a producer consumer
stack?</p>
  </li>
  <li>
    <p>Give me an implementation of a reader-writer lock with condition
variables, make a struct with whatever you need, it needs to be able
to support the following functions</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    
    
<span class="p">}</span> <span class="n">rw_lock_t</span><span class="p">;</span>
    
<span class="kt">void</span> <span class="nf">reader_lock</span><span class="p">(</span><span class="n">rw_lock_t</span><span class="o">*</span> <span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
    
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">writer_lock</span><span class="p">(</span><span class="n">rw_lock_t</span><span class="o">*</span> <span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
    
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">reader_unlock</span><span class="p">(</span><span class="n">rw_lock_t</span><span class="o">*</span> <span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
    
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">writer_unlock</span><span class="p">(</span><span class="n">rw_lock_t</span><span class="o">*</span> <span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
    
<span class="p">}</span>
</code></pre></div>    </div>

    <p>The only specification is that in between <code class="highlighter-rouge">reader_lock</code> and
<code class="highlighter-rouge">reader_unlock</code>, no writers can write. In between the writer locks,
only one writer may be writing at a time.</p>
  </li>
  <li>
    <p>Write code to implement a producer consumer using ONLY three
counting semaphores. Assume there can be more than one thread
calling enqueue and dequeue. Determine the initial value of each
semaphore.</p>
  </li>
  <li>
    <p>Write code to implement a producer consumer using condition
variables and a mutex. Assume there can be more than one thread
calling enqueue and dequeue.</p>
  </li>
  <li>
    <p>Use CVs to implement add(unsigned int) and subtract(unsigned int)
blocking functions that never allow the global value to be greater
than 100.</p>
  </li>
  <li>
    <p>Use CVs to implement a barrier for 15 threads.</p>
  </li>
  <li>
    <p>What does the following code do?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>
    
    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    
    <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Is the following code correct? If it isnât, could you fix it?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="n">money</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">deposit</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">money</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">withdraw</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">money</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">money</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Sketch how to use a binary semaphore as a mutex. Remember in
addition to mutual exclusion, a mutex can only ever be unlocked by
the thread who called it.</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">sem_t</span> <span class="n">sem</span><span class="p">;</span>
    
<span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
    
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
    
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>How many of the following statements are true?</p>

    <ul>
      <li>
        <p>There can be multiple active readers</p>
      </li>
      <li>
        <p>There can be multiple active writers</p>
      </li>
      <li>
        <p>When there is an active writer the number of active readers must
be zero</p>
      </li>
      <li>
        <p>If there is an active reader the number of active writers must
be zero</p>
      </li>
      <li>
        <p>A writer must wait until the current active readers have
finished</p>
      </li>
    </ul>
  </li>
</ul>
<div id="refs" class="references">

<div id="ref-dekker_dijkstra_1965">

Dekker, T.J., and Edsgar Dijkstra. 1965. âOver de Sequentialiteit van
Procesbeschrijvingen.â *E.W.Dijkstra Archive: Over de Sequentialiteit
van Procesbeschrijvingen (EWD 35)*. University of Texas Austin.
<a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD00xx/EWD35.html" class="fancy-link wiki-link">http://www.cs.utexas.edu/users/EWD/transcriptions/EWD00xx/EWD35.html</a>.

</div>

<div id="ref-Peterson1981MythsAT">

Peterson, Gary L. 1981. âMyths About the Mutual Exclusion Problem.â
*Inf. Process. Lett.* 12: 115â16.

</div>

</div>
</div></div></div>
</div></div>
</div>
          
          <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_coursebook/Synchronization.md";
  </script>
  <!-- Mathjax takes a while to load so do a lazy load to so we can get accessibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>

<!-- Bring in JQuery and Bootstrap -->
<script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" crossorigin="anonymous"></script>

<footer class="">

<!-- Add another container at the bottom so there is some space there -->
<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>

<!-- Mirrored from cs241.cs.illinois.edu/coursebook/Synchronization by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 17 Dec 2019 18:37:32 GMT -->
</html>
